**Sentry错误分析和过滤**

## **处理rrweb插件捕获错误的流程**

先判断对应的错误信息是否含有堆栈信息，如果有堆栈信息，那么遍历堆栈信息（一个录制json可能存在多个exceptionFrames），使用source-map根据map文件、行号、列号进行还原，得到原代码的行列号、文件路径、具体代码等信息，然后通过Gitlab的api 根据文件路径、行列号来获取提交信息，定位出错代码开发者。然后把回放页面、出错路径、出错位置、出错代码、提交者信息在KIM中进行通知。

**如果可以获取对应行数代码的提交者，则返回提交者和最近一次文件的提交者**

**如果对应行数的代码提交者已经离职，则返回最近一次文件的提交者**

需要过滤的错误类型

npm包内部的错误：例如axios这种过滤不通知

没有堆栈信息的错误：不通知

错误文件路径不支持的：不通知

有堆栈信息但是没有对应文件路径的

## rrweb

**sentry学习**

sentry扮演着一个错误收集的角色，将你的项目和sentry结合起来，无论谁在项目使用中报错，sentry都会第一次时间通知开发者，我们需要在系统异常时主动对其进行收集上报，出现了什么错误，错误出现在哪，帮你记录错误，以制定解决方案并进行优化迭代。

### **什么是DSN**

DSN是连接客户端(项目)与sentry服务端,让两者能够通信的钥匙；每当我们在sentry服务端创建一个新的项目，都会得到一个独一无二的DSN，也就是密钥。在客户端初始化时会用到这个密钥，这样客户端报错，服务端就能抓到你对应项目的错误了。之前版本的sentry对于密钥分为公钥和私钥，一般前端用公钥(DSN(Public))，但是现在的版本舍弃了这种概念，只提供了一个密钥。

### **什么是event**

每当项目产生一个错误，sentry服务端日志就会产生一个event，记录此次报错的具体信息。一个错误，对应一个event。

### **什么是issue**

同一类event的集合，一个错误可能会重复产生多次，sentry服务端会将这些错误聚集在一起，那么这个集合就是一个issue。

### **什么是Raven**

raven是sentry官方针对vue推荐的插件,我们在项目中初始化，让项目链接sentry的前提，都得保证已经引入了raven-js，以及我们手动提交错误的各类方法，都由Raven提供.

### **sentry for browser**

配置应该在应用程序的生命周期中尽早发生。

完成此操作后，Sentry 的 JavaScript SDK 会捕获所有未处理的异常和事务。复制



```
import * as Sentry from "@sentry/browser";

Sentry.init({
  dsn: "https://examplePublicKey@o0.ingest.sentry.io/0",

  // Alternatively, use `process.env.npm_package_version` for a dynamic release version
  // if your build tool supports it.
  release: "my-project-name@2.3.12",
  integrations: [new Sentry.BrowserTracing()],

  // Set tracesSampleRate to 1.0 to capture 100%
  // of transactions for performance monitoring.
  // We recommend adjusting this value in production
  tracesSampleRate: 1.0,
});
```



###  **rrweb 用法**



```
// rrweb replay
https://docs.sentry.io/platforms/javascript/guides/react/configuration/integrations/rrweb/

// 1. 安装依赖
npm install --save @sentry/rrweb rrweb

// 2. 修改Sentry.init()
import SentryRRWeb from '@sentry/rrweb';
Sentry.init({
  integrations: [
    // 配置信息 https://github.com/getsentry/sentry-rrweb
    new SentryRRWeb({
      checkoutEveryNms: 10 * 1000, // 每10秒重新制作快照
      checkoutEveryNth: 200, // 每 200 个 event 重新制作快照
      maskAllInputs: false, // 将所有输入内容记录为 *
    }),
  ],
  // ...
});

// 3. 触发错误 查看 REPLAY模块

// 4. 采样 抽样决定
// 为员工捕获这些错误
const hasReplays = getCurrentUser().isStaff;
let integrations = [];
if (hasReplays) {
  console.log("[sentry] Instrumenting session with rrweb");
  integrations.push(new SentryRRWeb());
}

Sentry.init({
  dsn: "https://examplePublicKey@o0.ingest.sentry.io/0",
  integrations,
});
// 设置标签方便我们可以在查询中使用
Sentry.setTag("rrweb.active", hasReplays ? "yes" : "no");
```



### **包结构分析**

- rrweb-snapshot：包含 snapshot 和 rebuild 两个功能。 snapshot 用于将 DOM 及其状态转化为可序列化的数据结构并添加唯一标识； rebuild 则是将 snapshot 记录的数据结构重建为对应的 DOM，并插入文档中 
- rrweb：包含 record 和 replay 两个功能。 **record 用于记录 DOM 中的所有变更（mutation）,record 负责从一开始录制 DOM 全量信息，到后面监听页面的变化（mutation），并将每次的变化 emit 出来传给开发用户**； replay 则是将记录的变更按照对应的时间一一重放。 
- rrweb-player：为 rrweb 提供一套 UI 控件，提供基于图形用户界面的暂停、快进、拖拽至任意时间点播放等功能。 
- rrdom：为node平台mock浏览器的dom，event等api 

整体思路：初始化时获取当前页面的全量快照，添加监听器监听页面不同类型的变化（比如 DOM 的变化以及鼠标、滚动以及页面 resize 等的变化），当以上这些变化（mutation）发生时，根据类型的不同分别进行不同的序列化处理，并将处理好的数据 emit 出来。序列化处理时，给每个序列化的 node 节点分配一个 ID，并维护一个从 ID 到 node 节点的映射以及一个 node 节点到序列化后 serializedNode 节点的映射。

工作流程

为了实现web界面录制与回放的功能，rrweb着重实现 dom元素的 [序列化](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Frrweb-io%2Frrweb%2Fblob%2Fmaster%2Fdocs%2Fserialization.md)、[增量快照](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Frrweb-io%2Frrweb%2Fblob%2Fmaster%2Fdocs%2Fobserver.md)、[回放](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Frrweb-io%2Frrweb%2Fblob%2Fmaster%2Fdocs%2Freplay.md) 和 [沙盒](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Frrweb-io%2Frrweb%2Fblob%2Fmaster%2Fdocs%2Fsandbox.zh_CN.md) 。

Sentry-rrweb是基于rrweb的一个Sentry插件，可以将前端应用程序的记录和回放事件上传到Sentry平台，以便开发人员更好地理解和调试用户反馈的问题。以下是Sentry-rrweb使用方法的基本步骤：

1.安装和引入Sentry-rrweb插件

通过npm安装sentry-rrweb插件，并在应用程序中引入。



```
npm install @sentry/rrweb
```





```
import * as Sentry from "@sentry/browser";
import { initRrweb } from "@sentry/rrweb";

Sentry.init({
  dsn: "YOUR_DSN",
  integrations: [
    new initRrweb({
      emit: (event) => {
        // 将事件发送到Sentry平台
        Sentry.addBreadcrumb({
          category: "rrweb",
          message: JSON.stringify(event),
          level: Sentry.Severity.Info,
        });
      },
    }),
  ],
});
```



初始化Recorder

创建Recorder实例，并指定要记录的**DOM元素和配置参数**。



```
const recorder = new rrweb.Record({
  emit(event) {
    // 将事件发送到Sentry插件
    Sentry.getCurrentHub().getIntegration(initRrweb).emit(event);
  },
  checkoutEveryNth: 10, // 每10个事件检查一次是否需要停止记录
  recordCanvas: false, // 是否记录canvas元素
  recordScroll: true, // 是否记录滚动事件
  recordMutation: true, // 是否记录DOM变化事件
  recordInput: true, // 是否记录输入事件
  recordMedia: true, // 是否记录媒体事件
  hooks: {
    // 钩子函数，用于拦截和修改事件
    beforeDispatch(event) {
      console.log('before dispatch', event);
      return event;
    },
    afterDispatch(event) {
      console.log('after dispatch', event);
    },
  },
});

recorder.record(document.getElementById('app')); // 开始记录
```



回放

创建Replayer实例，并指定要回放的**事件序列和配置参数**。



```
const replayer = new rrweb.Replayer(events, {
  root: document.getElementById('app'), // 指定回放的根元素
  skipInactive: true, // 是否跳过非活动事件（例如滚动事件）
  speed: 1, // 回放速度
  showWarning: true, // 是否显示警告信息
  showDebug: true, // 是否显示调试信息
  blockClass: 'block', // 隐藏指定的CSS类
  liveMode: false, // 是否开启实时模式
  pauseAfterRound: false, // 回放一轮后是否暂停
  plugins: [], // 插件列表
});

replayer.play(); // 开始回放
```



以上是Sentry-rrweb使用方法的基本步骤，可以根据实际需求调整参数和使用插件扩展功能。注意：在使用Sentry-rrweb插件时，需要先初始化Sentry SDK，并将插件添加到integrations中。

rrweb是一个开源的Web页面录制和回放库。以下是rrweb中record方法的参数说明：



```
interface RecordOptions {
  emit?: (event: eventWithTime, isCheckout?: boolean) => void;
  checkoutEveryNth?: number;
  checkoutEveryNms?: number;
  blockClass?: string;
  ignoreClass?: string;
  maskAllInputs?: boolean;
  maskInputOptions?: {
    color?: string;
    backgroundColor?: string;
    borderRadius?: string;
    boxShadow?: string;
    zIndex?: string;
  };
  slimDOMOptions?: SlimDOMOptions;
  recordCanvas?: boolean;
  collectFonts?: boolean;
  showWarning?: boolean;
}
```



emit?: (event: eventWithTime, isCheckout?: boolean) => void：一个回调函数，用于处理每个记录的事件。eventWithTime是一个包含事件类型和时间戳的事件对象。isCheckout参数表示是否需要进行快照，如果为true，则需要进行快照，否则不需要。如果不提供此参数，则默认为false。

checkoutEveryNth?: number：指定每隔多少个事件进行一次快照。例如，如果设置为10，则每记录10个事件就会进行一次快照。如果不提供此参数，则默认为null，表示不使用此选项。

checkoutEveryNms?: number：指定每隔多少毫秒进行一次快照。例如，如果设置为1000，则每隔1秒就会进行一次快照。如果不提供此参数，则默认为null，表示不使用此选项。

blockClass?: string：指定需要屏蔽的DOM元素的类名。例如，如果设置为'block'，则所有类名为'block'的DOM元素都会被屏蔽。如果不提供此参数，则默认为'rr-block'。

ignoreClass?: string：指定需要忽略的DOM元素的类名。例如，如果设置为'ignore'，则所有类名为'ignore'的DOM元素都会被忽略。如果不提供此参数，则默认为'rr-ignore'。

maskAllInputs?: boolean：一个布尔值，表示是否需要屏蔽所有输入框。如果为true，则所有输入框都会被屏蔽。如果不提供此参数，则默认为false。

maskInputOptions?: object：一个包含屏蔽输入框选项的对象。可以指定颜色、背景色、圆角、阴影和z-index等选项。

slimDOMOptions?: SlimDOMOptions：一个包含SlimDOM选项的对象。SlimDOM是一种针对DOM树的优化方案，可以减少数据量和内存使用。可以指定要保留的DOM元素和属性等选项。

recordCanvas?: boolean：一个布尔值，表示是否需要记录canvas元素。如果为true，则所有canvas元素都会被记录。如果不提供此参数，则默认为false。

collectFonts?: boolean：一个布尔值，表示是否需要收集字体信息。如果为true，则会收集页面中使用的所有字体信息。如果不提供此参数，则默认为false。

showWarning?: boolean：一个布尔值，表示是否需要显示警告信息。如果为true，则会在控制台中显示警告信息。如果不提供此参数，则默认为false。

在rrweb中，事件对象（Event）包含了一个delay属性，用于指定该事件相对于前一个事件的延迟时间。这个属性的值是一个整数，表示该事件相对于前一个事件的时间间隔（单位是毫秒）。通常情况下，delay属性用于调整事件回放的速度，可以通过增加或减少该属性的值来控制事件之间的时间间隔。例如，将delay属性设置为1000，表示该事件与前一个事件之间的时间间隔为1秒。

在Sentry JavaScript插件中，可以通过以下方式获取事件ID和问题ID：

事件ID：在Sentry捕获异常或记录日志时，会返回一个Promise对象。可以通过该Promise对象的then()方法获取事件ID。例如：



```
Sentry.captureException(new Error('Something went wrong'))
  .then(eventId => console.log('Event ID:', eventId));
```



问题ID：在Sentry中，每个问题都有一个唯一的问题ID。可以在Sentry控制台中查看问题ID，也可以通过Sentry API获取。例如：



```
Sentry.showReportDialog({
  eventId: 'EVENT_ID',
  onSuccess: function(dialogId) {
    Sentry.API.issue(SENTRY_ISSUE_ID).then(function(issue) {
      console.log('Issue ID:', issue.id);
    });
  }
});
```



其中，eventId是事件ID，onSuccess是对话框提交成功后的回调函数，在该回调函数中可以获取问题ID。Sentry.API.issue()方法用于获取问题详情，需要传入问题ID作为参数。

//sentry怎么获取报错信息？

//首先获取对应的错误堆栈信息 通过sourcemap获取打包前的报错文件名 报错行数 列数 通过 sentry获取 在插件sdk里面完成获取

//通过git blame获取对应作者信息  在sdk里面获取  项目里面不一定支持

//git blame - L linenumber, linenumber filename.txt

/*

这个命令将会显示 filename.txt 文件中第 linenumber 行的详细信息，包括这个提交的作者、提交时间和提交信息。

需要注意的是，git blame 命令可以帮助你了解文件的变更历史，但是它并不能判断这些变更是否正确或者合理。

因此，在使用 git blame 进行代码审查或修改时，需要综合考虑多个因素，如代码质量、可读性、可维护性等。

*/

// 把对应堆栈 报错信息  行数 列数 以及文件名  作者信息存入数据库

// 在对应rrweb上传的时候 或者捕获的时候  发送请求给node服务  sendkim 把对应的开发者 对应的项目名 文件名 对应的行列号 对应的报错原因 报错时间  在kim里面进行通知

//怎么去测试

//插件引入本地 然后在璇玑里面进行抛出错误

//数据库需要加入的字段 occurTime  frame  fileName  lineNum colNum  commitUser



```
{
"event_id": "05b6a895b6e14b299a832fb9acabf367",
"project": 12345,
"timestamp": "2022-05-01T12:34:56.789Z",
"platform": "javascript",
"logger": "javascript",
"culprit": "main.js",
"message": "Uncaught TypeError: Cannot read property 'foo' of undefined",
"level": "error",
"exception": {
"values": [
{
 "type": "TypeError",
 "value": "Cannot read property 'foo' of undefined",
 "stacktrace": {
   "frames": [
     {
       "function": "getFoo",
       "filename": "http://example.com/js/main.js",
       "lineno": 123,
       "colno": 45
     },
     {
       "function": "init",
       "filename": "http://example.com/js/main.js",
       "lineno": 99,
       "colno": 12
     },
     {
       "function": "onload",
       "filename": "http://example.com/js/main.js",
       "lineno": 10,
       "colno": 34
     }
   ]
 }
}
]
},
"request": {
"url": "http://example.com/",
"headers": {},
"method": "GET"
}
}
```

##  **ECMAScript Execeptions**

[各种内建的标准错误类型](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Error)

### **Error**

基础的错误对象



```
try {
        throw new Error("错误了");
      } catch (err) {
        console.log("err.name", err.name);
        console.log("err.message", err.message);
        console.log("err.stack", err.stack);
        console.log("err.constructor:", err.constructor);
      }
```



![img](https://femarkdownpicture.oss-cn-qingdao.aliyuncs.com/imgs/out-20231229145104817.png)

### **InternalError**

出现在JavaScript引擎内部的错误,只有 firefox 支持

产生原因：过多 case 语句,正则表达式中括号过多,递归过深,内存溢出等

### **RangeError**

- 当一个值不在其允许的范围或者集合中
- 当传递一个不合法的length值作为 Array 构造器的参数创建数组
- 传递错误值到数值计算方法( Number.toExponential()，Number.toFixed(), Number.toPrecision()等）

### **ReferenceError**

一个不存在的变量被引用时发生的错误

当代码中存在引用未定义变量或函数时，JavaScript 引擎就会抛出 ReferenceError 错误。这通常发生在以下几种情况：

**变量或函数名未定义**：例如，当尝试使用一个没有声明过的变量时，就会抛出 ReferenceError 错误。



```
console.log(a); // ReferenceError: a is not defined
```



**对象属性未定义**：例如，当尝试访问一个未定义的对象属性时，就会抛出 ReferenceError 错误。



```
var obj = {};
console.log(obj.foo); // ReferenceError: obj.foo is not defined
```



**使用 delete 操作符删除不存在的属性**：例如，当尝试删除一个对象中不存在的属性时，就会抛出 ReferenceError 错误。



```
var obj = {};
delete obj.foo; // ReferenceError: obj.foo is not defined
```



在 JavaScript 中，ReferenceError 错误通常是由编程错误引起的，例如拼写错误、变量声明的位置错误等。

### **SyntaxError**

- 解析语法上不合法的代码的错误
- 不能被用户代码catch的SyntaXError

当代码中存在语法错误时，JavaScript 引擎就会抛出 SyntaxError 错误。

**语法错误：**例如，当代码中存在括号不匹配、语句不完整、操作符使用错误等语法错误时，就会抛出 SyntaxError 错误。



```
console.log(1; // SyntaxError: missing ) after argument list
```



**非法字符：**例如，当代码中存在非法字符时，就会抛出 SyntaxError 错误。



```
console.log('hello'》); // SyntaxError: Invalid or unexpected token
```



**非法转义字符：**例如，当代码中存在非法的转义字符时，就会抛出 SyntaxError 错误。



```
console.log('hello\''); // SyntaxError: unterminated string literal
```



### **TypeError**

当在代码中使用了不支持的操作或类型时，JavaScript 引擎就会抛出 TypeError 错误

1. **尝试访问未定义或空对象的属性或方法。**

访问未定义或空对象的属性或方法时，会产生TypeError。例如：



```
let person = {};
console.log(person.name); // 输出 "undefined"
console.log(person.name.length); // TypeError: Cannot read property 'length' of undefined
```



1. 尝试调用非函数类型的变量或属性。



```
let message = "Hello, world!";
console.log(message()); // TypeError: message is not a function
```



1. 尝试对非数组或类数组对象执行数组操作，如push、pop等。



```
let name = "John";
name.push("Doe"); // TypeError: name.push is not a function
```



1. 尝试使用未声明的变量或属性。



```
console.log(age); // ReferenceError: age is not defined
console.log(user.age); // TypeError: Cannot read property 'age' of undefined
```



1. 尝试使用不支持的类型进行操作，如使用null或undefined进行算术操作。



```
let person = null;
let age = 30;
console.log(age/person); // TypeError: Cannot convert object to primitive value
```



值的类型非预期类型时发生的错误



```
undefined.abc
null.abc
new 123()
"1" in "123"
const a = 1
a = 2
```



**错误关键词**



```
Cannot read property of undefined
Cannot read properties of  
is not a constructor
Assignment to constant variable.
```



### **URIError**

当使用不合法的 URL 或 URI 参数时，JavaScript 引擎就会抛出 URIError 错误。

**在 URI 中包含非法字符：**例如，当我们使用不合法的字符（如空格、#、%等）作为 URI 参数时，就会抛出 URIError 错误。



```
let url = 'https://www.example.com/search?q=how to use javascript#basics';
let encodedUrl = encodeURI(url);
console.log(encodedUrl); // https://www.example.com/search?q=how%20to%20use%20javascript#basics
```



**在字符串转换为 URI 时遇到错误：**例如，当我们尝试使用 encodeURI() 或 decodeURI() 方法转换不合法的字符串时，就会抛出 URIError 错误。



```
let url = 'https://www.example.com/search?q=how to use javascript#basics';
let encodedUrl = encodeURI(url);
let decodedUrl = decodeURIComponent(encodedUrl); // URIError: malformed URI sequence
```



URIError 错误通常是由于使用不合法的 URL 或 URI 参数或字符编码错误引起的。应该使用 URL 和 URI 相关的 JavaScript 方法，如 encodeURI()、encodeURIComponent()、decodeURI() 和 decodeURIComponent() 来正确处理 URL 和 URI，以避免出现这类错误。

### **AggregateError**

它是在多个操作中发生错误时将多个错误合并成一个单独的错误对象。AggregateError 错误对象包含一个数组，其中每个元素都是一个单独的错误对象。这个错误类型可以用于异步操作中，以便将多个操作的错误报告给用户。

在使用 Promise.all() 或 Promise.allSettled() 方法时，如果其中一个 Promise 对象发生错误，那么 Promise.all() 或 Promise.allSettled() 方法就会返回一个 AggregateError 类型的错误对象。这个错误对象包含了所有发生错误的 Promise 对象的错误信息。



```
const promise1 = Promise.resolve(1);
const promise2 = Promise.reject(new Error('Error 1'));
const promise3 = Promise.reject(new Error('Error 2'));

Promise.all([promise1, promise2, promise3])
  .then(values => console.log(values))
  .catch(error => {
    if (error instanceof AggregateError) {
      console.log(error.errors); // [Error: Error 1, Error: Error 2]
    }
});
```



在处理多个异步操作时，AggregateError 错误类型可以帮助我们更好地捕获和处理所有发生的错误信息。

## **DOMException**

[**DOMException**](https://developer.mozilla.org/zh-CN/docs/Web/API/DOMException#Error_names)接口代表调用方法或访问 Web API 属性时发生的异常事件（被称为**异常**，**exception**）**用于表示在操作 DOM 树时可能发生的错误**

在标准的 DOM API 中，DOMException 对象通常不包含堆栈跟踪信息。这是因为 DOMException 是在底层的浏览器引擎中抛出的，而不是在 JavaScript 的执行上下文中。

在捕获 DOMException 时获取堆栈跟踪信息，可以使用标准的 JavaScript 异常处理机制。通过使用 try...catch 语句来捕获 DOMException，并使用 console.trace() 或 console.error() 打印堆栈跟踪信息。

DOMException.message 

返回一个 DOMString 代表与给定的错误名称有关信息或描述。

DOMException.name 

返回一个 DOMString 包含与错误名称相关的字符串

IndexSizeError：索引大小错误，表示给定的索引值超出了允许的范围。

HierarchyRequestError：层次请求错误，表示节点在 DOM 树中的位置不允许执行请求的操作。

WrongDocumentError：错误的文档错误，表示节点和操作不属于同一个文档。

InvalidCharacterError：无效字符错误，表示字符串中包含无效的字符。

NoModificationAllowedError：不允许修改错误，表示对只读或不允许修改的对象进行了修改操作。

NotFoundError：未找到错误，表示未找到请求的节点或对象。

NotSupportedError：不支持错误，表示请求的操作不受当前环境或对象的支持。

InvalidStateError：无效状态错误，表示对象处于无效或不允许执行请求操作的状态。

SyntaxError：语法错误，表示传递给方法或函数的参数具有无效的语法。

InvalidModificationError：无效修改错误，表示对对象进行了无效的修改操作。

NamespaceError：命名空间错误，表示操作涉及无效的命名空间。

InvalidAccessError：无效访问错误，表示对对象的访问无效或被拒绝。

TypeMismatchError：类型不匹配错误，表示传递给方法或函数的参数的类型不匹配。

SecurityError： 安全错误，表示操作被安全限制或违反了安全策略。

**NetworkError：** 发生网络错误。通常在使用 Fetch API 或 XMLHttpRequest 进行网络请求时发生

**AbortError**： 操作被中止。   通常为主动中断或者再请求时进行页面导航

URLMismatchError： 给定的URL不匹配另一个URL。

QuotaExceededError：给定配额已经超过了。

TimeoutError： 操作超时。

InvalidNodeTypeError： 这个操作的节点是不正确的或祖先是不正确的。

DataCloneError： 对象不能克隆。

## **Axios的createError**

`createError` 是 `axios` 库中的一个函数，用于创建一个 `Error` 对象。

在 `axios` 库中，当发生错误时，会调用 `createError` 函数来创建一个错误对象，然后将这个错误对象作为 Promise 的拒绝值返回给调用方。

`createError` 函数的定义如下：



```
function createError(message, config, code, request, response) {
  const error = new Error(message);
  return enhanceError(error, config, code, request, response);
}
```



它接受五个参数：

- `message`：错误信息。
- `config`：请求配置对象。
- `code`：HTTP 状态码。
- `request`：XMLHttpRequest 对象的实例。
- `response`：响应对象。

`createError` 函数首先创建一个普通的 `Error` 对象，并将 `message` 作为参数传入。然后，它调用 `enhanceError` 函数，将创建的 `Error` 对象和其他参数一起传入，以创建一个更完整的错误对象，最终将这个错误对象返回。

`enhanceError` 函数的作用是将传入的参数添加到错误对象的属性中，然后返回这个错误对象。由于 `createError` 函数返回的是 `enhanceError` 函数的返回值，因此最终返回的是一个多了一些属性的错误对象，这个错误对象包含了详细的错误信息，以及一些请求和响应的相关信息。

enhanceError 方法就是单纯为了升级 Error 对象，给 Axios 生成的错误对象添加 config、code、request 和 response 属性



```
function enhanceError(error, config, code, request, response) {
  error.config = config;
  if (code) {
    error.code = code;
  }
  error.request = request;
  error.response = response;
  error.isAxiosError = true;

  // 添加其他自定义属性或方法

  return error;
}
```



## **Throw**

用于抛出异常并停止代码执行。当代码运行到一个 throw 语句时，程序会停止执行并抛出一个异常对象。如果没有被处理，**这个异常对象会向上冒泡到调用栈的上一级，并继续向上直到被处理或者到达全局作用域，此时会导致程序崩溃。**

## **错误捕获**

### **脚本错误**

**脚本错误参数对象** instanceof ErrorEvent

**脚本错误的捕获方式有：**

try catch：通过try...catch我们能够知道出错的信息,并且也有堆栈信息可以知道在哪个文件第几行第几列发生错误。只能捕获同步代码的异常，需要await进行转化

window.onerror：能全局捕获错误，可以拿到出错的信息以及文件名、行号、列号等信息；能捕获即时运行错误，不能捕获资源加载错误

### **资源加载错误**

**资源加载错误包括：img、script、link、audio、video、iframe**

资源加载错误没有message，资源错误的参数对象 instanceof Event

捕获方式：

object.onerror：如：img标签、script标签都可以添加onerror事件，用来捕获资源加载错误

### **Promise错误**

try catch和window.onerror是无法捕捉Promise错误的（因为是异步）

而当 Promise 被 reject 且没有 reject 处理器的时候，会触发 unhandledrejection 事件

当 Promise 被 reject 且有 reject 处理器的时候，会触发 rejectionhandled 事件。

说明：Sentry这边只收集没有被reject的错误即window.unhandledrejection

### **异常传播和处理**

JS 中异常传播是自动的，不需要程序员手动地一层层传递。如果一个异常没有被 catch，它会沿着函数调用栈一层层传播直到栈空。

**throw（抛出异常）** 和 **catch（处理异常）**。 当一个异常被抛出的时候，异常的传播就开始了。异常会不断传播直到遇到第一个 catch。 如果程序员没有手动 catch，那么一般而言程序会抛出类似**unCaughtError**，表示发生了一个异常，并且这个异常没有被程序中的任何 catch 语言处理。未被捕获的异常通常会被打印在控制台上，里面有详细的堆栈信息，从而帮助程序员快速排查问题。实际上我们的程序的目标是**避免 unCaughtError**这种异常，而不是一般性的异常。

JS 的 Error 对象没有 code 属性，只能根据 message 来呈现



```
function a() {
  b();
}
function b() {
  c();
}
function c() {
  throw new Error("an error  occured");
}
a();
```



![img](https://femarkdownpicture.oss-cn-qingdao.aliyuncs.com/imgs/out-20231229145105671.png)

没有 catch 错误，因此上面才会有**uncaught Error,并且为错误输出**



```
function a() {
  b();
}
function b() {
  c();
}
function c() {
  try {
    throw new Error("an error  occured");
  } catch (err) {
    console.log(err);
  }
}
a();
```



![img](https://femarkdownpicture.oss-cn-qingdao.aliyuncs.com/imgs/out-20231229145106192.png)

没有**uncaught Error**

## **Sentry对错误信息的处理**

针对事件处理sentry内部主要是使用了_installGlobalOnErrorHandler

和_installGlobalOnUnhandledRejectionHandler

_installGlobalOnErrorHandler对event处理



```
          const event = isPrimitive(error)
            ? this._eventFromIncompleteOnError(...)
            : this._enhanceEventWithInitialFrame(
                eventFromUnknownInput(...))
```



_installGlobalOnUnhandledRejectionHandler



```
          const event = isPrimitive(error)
            ? this._eventFromRejectionWithPrimitive(...)
            : eventFromUnknownInput(...);
```



通过isPrimitive去判断错误类型是基本类型还是引用类型而走不同的操作

### **eventFromUnknownInput**



```
eventFromUnknownInput(error, undefined, {
  attachStacktrace: client && client.getOptions().attachStacktrace,
  rejection: false,
}) 
 // exception为错误信息，options是用户在Sentry.init中设置的attachStacktrace
function eventFromUnknownInput(
  exception: unknown,
  syntheticException?: Error,
  attachStacktrace?: boolean,
  isUnhandledRejection?: boolean,
): Event {
  let event: Event;

  if (isErrorEvent(exception as ErrorEvent) && (exception as ErrorEvent).error) {
    // If it is an ErrorEvent with `error` property, extract it to get actual Error
    const errorEvent = exception as ErrorEvent;
    return eventFromError(errorEvent.error as Error);
  }

  // If it is a `DOMError` (which is a legacy API, but still supported in some browsers) then we just extract the name
  // and message, as it doesn't provide anything else. According to the spec, all `DOMExceptions` should also be
  // `Error`s, but that's not the case in IE11, so in that case we treat it the same as we do a `DOMError`.
  //
  // https://developer.mozilla.org/en-US/docs/Web/API/DOMError
  // https://developer.mozilla.org/en-US/docs/Web/API/DOMException
  // https://webidl.spec.whatwg.org/#es-DOMException-specialness
  if (isDOMError(exception as DOMError) || isDOMException(exception as DOMException)) {
    const domException = exception as DOMException;

    if ('stack' in (exception as Error)) {
      event = eventFromError(exception as Error);
    } else {
      const name = domException.name || (isDOMError(domException) ? 'DOMError' : 'DOMException');
      const message = domException.message ? `${name}: ${domException.message}` : name;
      event = eventFromString(message, syntheticException, attachStacktrace);
      addExceptionTypeValue(event, message);
    }
    if ('code' in domException) {
      event.tags = { ...event.tags, 'DOMException.code': `${domException.code}` };
    }

    return event;
  }
  if (isError(exception)) {
    // we have a real Error object, do nothing
    return eventFromError(exception);
  }
  if (isPlainObject(exception) || isEvent(exception)) {
    // If it's a plain object or an instance of `Event` (the built-in JS kind, not this SDK's `Event` type), serialize
    // it manually. This will allow us to group events based on top-level keys which is much better than creating a new
    // group on any key/value change.
    const objectException = exception as Record<string, unknown>;
    event = eventFromPlainObject(objectException, syntheticException, isUnhandledRejection);
    addExceptionMechanism(event, {
      synthetic: true,
    });
    return event;
  }

  // If none of previous checks were valid, then it means that it's not:
  // - an instance of DOMError
  // - an instance of DOMException
  // - an instance of Event
  // - an instance of Error
  // - a valid ErrorEvent (one with an error property)
  // - a plain Object
  //
  // So bail out and capture it as a simple message:
  event = eventFromString(exception as string, syntheticException, attachStacktrace);
  addExceptionTypeValue(event, `${exception}`, undefined);
  addExceptionMechanism(event, {
    synthetic: true,
  });

  return event;
}
```



isErrorEvent



```
 错误类型是ErrorEvent，包含比较详细的错误信息
function isErrorEvent(wat) {
    return Object.prototype.toString.call(wat) === '[object ErrorEvent]';
  }
```



isDOMError  isDOMException



```
  function isDOMError(wat) {
    return Object.prototype.toString.call(wat) === '[object DOMError]';
  }
  
   function isDOMException(wat) {
    return Object.prototype.toString.call(wat) === '[object DOMException]';
  }
```



isError 



```
  function isError(wat) {
    switch (Object.prototype.toString.call(wat)) {
      case '[object Error]':
        return true;
      case '[object Exception]':
        return true;
      case '[object DOMException]':
        return true;
      default:
        return isInstanceOf(wat, Error);
    }
  }
```



isPlainObject或者isEvent针对普通消息



```
  function isEvent(wat) {
    return typeof Event !== 'undefined' && isInstanceOf(wat, Event);
  }

  function isPlainObject(wat) {
    return Object.prototype.toString.call(wat) === '[object Object]';
  }
```



处理eventFromStacktrace，eventFromPlainObject，eventFromString 都是拿到错误消息进行更进一步的数据处理。

### **computeStackTrace 获取错误堆栈**

computeStackTrace主要获取当前的错误堆栈

把stack进行split转换数组，然后根据浏览器信息做不同处理，

最后返回stack是带有args，line，func，url的数据格式



```
args: []
column: 9
func: "externalLibrary"
line: 2
url: ""
```



##### **eventFromStacktrace、eventFromString和 eventFromPlainObject**

拿到错误堆栈等信息进行进一步处理



```
  function eventFromStacktrace(stacktrace) {
    const exception = exceptionFromStacktrace(stacktrace);
    return {
      exception: {
        values: [exception],
      },
    };
  }
--------------------------------------------------------------------------------------------
  function eventFromString(input, syntheticException, options = {}) 	{
    const event = {
      message: input,
    };
    if (options.attachStacktrace && syntheticException) {
      const stacktrace = computeStackTrace(syntheticException);
      const frames = prepareFramesForEvent(stacktrace.stack);
      event.stacktrace = {
        frames,
      };
    }
    return event;
  }
-------------------------------------------------------------------------------------------
function eventFromPlainObject(exception, syntheticException, rejection) {
    const event = {
      exception: {
        values: [
          {
            type: isEvent(exception) ? exception.constructor.name : rejection ? 'UnhandledRejection' : 'Error',
            value: `Non-Error ${
              rejection ? 'promise rejection' : 'exception'
            } captured with keys: ${extractExceptionKeysForMessage(exception)}`,
          },
        ],
      },
      extra: {
        __serialized__: normalizeToSize(exception),
      },
    };
    if (syntheticException) {
      const stacktrace = computeStackTrace(syntheticException);
      const frames = prepareFramesForEvent(stacktrace.stack);
      event.stacktrace = {
        frames,
      };
    }
    return event;
  }
```



最终返回的数据



```
  exception:  {
      stacktrace: [
        {
          colno: 1,
          filename:
          'https://',
          function: '?',
          in_app: true,
          lineno: 5,
        },
        {
          colno: 9,
          filename:
            'https://',
          function: 'externalLibrary',
          in_app: true,
          lineno: 2,
        },
      ];
      type: 'Error';
      value: 'externalLibrary method broken';
    }
```



错误消息的类型去走eventFromStacktrace、eventFromString和 eventFromPlainObject其中的一个方法。**像错误类型为DOMError、DOMException、普通对象的此时是没有错误堆栈的消息的**，而其他的会通过computeStackTrace去抹平不同浏览器的差异，获取错误堆栈，最后对错误数据处理返回统一的结构。

对window.onerror和window.unhandledrejection进行劫持

| 错误类型                     | 捕获方式                                     | 处理函数                           | 详情                     |
| ---------------------------- | -------------------------------------------- | ---------------------------------- | ------------------------ |
| throw '错误测试'             | window.onerror 的 错误类型是基本类型         |                                    | 有错误栈信息             |
| throw new Error(' 错误测试') | window.onerror 的 错误类型是引用类型         | eventFromPlainObject()             | 有错误栈消息             |
|                              | window.error 不上报错误                      |                                    | 不进行错误报没有错误信息 |
| reject('错误测试')           | window.unhandledrejection 错误类型是基本类型 | _eventFromRejectionWithPrimitive() | 没有错误栈信息           |
| reject(obj)                  | window.unhandledrejection 错误类型是引用类型 | eventFromPlainObject()             | 没有错误栈信息           |
|                              | 引用类型并且是DOMException                   | eventFromUnknownInput()            | 没有错误栈信息           |

## **提取分析错误**

按照项目来区分，璇玑系统，时间最近一个月，

### **1.查询接口**

区分为2大类：所有错误  、可回溯定位错误

 需要查询分析的：错误类型（按照js的错误类型区分），错误源分类 ，错误模块，错误时间（按照周）

错误类型：按照errorMessage或者errorType进行字符判断，然后计入

错误源分类：按照sourcepath 进行判断 可回溯的 还有具体是哪报错了

错误模块：错误的路径分析，通过路径确定是那个业务模块下的代码

错误时间：按照发生时间进行计算数量分析

### **2.展示页面**

错误类型，饼图展示最近一个月的各种错误的占比和数量  有类型和数量

错误源分类，饼图分析最近一个月的错误源分类（业务代码，npm包，浏览器兼容性，模版错误）

错误模块，饼图展示各个业务模块的占比   

错误时间，做一个饼图占比或者按时间的条形图



```
AxiosError	
CanceledError	
Error	
IndexSizeError	
InvalidStateError	
NavigationDuplicated	
NotAllowedError	
NotFoundError	
NotSupportedError	
RangeError	
ReferenceError	
SyntaxError	
TypeError	
URIError
```





```
AxiosError	71	
CanceledError	20929	
Error	18981	
IndexSizeError	8	
InvalidStateError	3	
NavigationDuplicated	58	
NotAllowedError	9	
NotFoundError	3	
NotSupportedError	208	
RangeError	14	
ReferenceError	2	
SyntaxError	196	
TypeError	4643	
URIError  15
```

Todos:

1.错误原因分析

通过字段进行更详细的分析  **DOMException  浏览器版本问题**  

**es6的api基本都支持**

**es7**

**es 10以上api需要考虑一下**

ECMAScript 2019（也称为 ES10 或 ES2019）引入了一些新的 JavaScript API。以下是其中的一些：

Array.prototype.flat() 和 Array.prototype.flatMap(): 这两个方法用于处理嵌套数组。flat() 方法将嵌套数组展平为一个新数组，而 flatMap() 方法在展平数组的同时，还可以对每个元素进行映射和操作。

Object.fromEntries(): 这个静态方法将键值对数组转换为对象。它接受一个键值对数组（如 [[key1, value1], [key2, value2]]）作为参数，并返回一个由这些键值对组成的新对象。

String.prototype.trimStart() 和 String.prototype.trimEnd(): 这两个方法用于去除字符串开头或结尾的空格字符。trimStart() 方法去除开头的空格，trimEnd() 方法去除结尾的空格。

Symbol.prototype.description: 这个属性用于获取 Symbol 对象的描述字符串。它返回一个可读的字符串，表示 Symbol 的描述信息。

ECMAScript 2020（也称为 ES11 或 ES2020）引入了一些新的 JavaScript API。以下是其中的一些：

BigInt: BigInt 是一种新的原始数据类型，用于表示任意精度的整数。它允许处理超过 Number 数据类型所能表示的范围的整数。

Promise.allSettled(): 这个静态方法接受一个 Promise 数组，并返回一个新的 Promise，该 Promise 在所有输入 Promise 完成（无论是成功还是失败）后解析。与 Promise.all() 不同，Promise.allSettled() 不会在任何一个 Promise 失败时立即拒绝。

String.prototype.matchAll(): 这个方法返回一个包含所有匹配正则表达式的迭代器对象。您可以使用它来遍历一个字符串中所有匹配的结果。

globalThis: 这是一个全局对象的新属性，可以在任何环境中访问全局对象，无论是在浏览器中还是在 Node.js 环境中。

ECMAScript 2021（也称为 ES12 或 ES2021）引入了一些新的 JavaScript API。以下是其中的一些：

String.prototype.replaceAll(): 这个方法接受两个参数，用于将字符串中的所有匹配项替换为指定的新字符串。与 replace() 方法不同，replaceAll() 替换所有匹配项，而不仅仅是第一个匹配项。

Promise.any(): 这个静态方法接受一个 Promise 数组，并返回一个新的 Promise，该 Promise 在输入 Promise 数组中的任何一个 Promise 完成（即解决或拒绝）时解析。与 Promise.race() 方法不同，Promise.any() 只要有一个 Promise 完成就解析，而不是第一个完成的 Promise。

WeakRef 和 FinalizationRegistry: 这两个 API 是用于处理弱引用的。WeakRef 对象允许创建对对象的弱引用，而 FinalizationRegistry 对象允许在对象被垃圾回收时执行清理操作。

Logical Assignment Operators: 这些是逻辑赋值运算符，包括 ||=、&&= 和 ??=。它们允许在进行逻辑运算的同时进行赋值操作，简化了一些常见的编程模式。

正则零宽断言低版本safari浏览器报错



```
SyntaxError: Invalid regular expression: invalid group specifier name
```



**意思就是，正则表达式无效：组说明符名称无效。**

什么是零宽断言？

用于查找在某些内容(但并不包括这些内容)之前或之后的东西，也就是说它们像\b,^,$那样用于指定一个位置，这个位置应该满足一定的条件(即断言)，因此它们也被称为零宽断言。最好还是拿例子来说明吧： 断言用来声明一个应该为真的事实。正则表达式中只有当断言为真时才会继续进行匹配。

正则零宽断言，一共4种 1、(?=xxx) 例：\b\w+(?=ing\b)，匹配以ing结尾的单词的前面部分 2、(?<=xxx) 例：(?<=\bre)\w+\b会匹配以re开头的单词的后半部分 3、(?!xxx) 例：\d{3}(?!\d)匹配三位数字，而且这三位数字的后面不能是数字 4、(?<!xxx) 例：(?<![a-z])\d{7}匹配前面不是小写字母的七位数字

![img](https://docs.corp.kuaishou.com/image/api/external/load/out?code=fcAC6Q4hC1fDITvyf2nUK_1pB:-5164182880490647560fcAC6Q4hC1fDITvyf2nUK_1pB:1703834444256)

https://blog.csdn.net/xiamocsdn/article/details/125221297

[**https://caniuse.com/**](https://caniuse.com/)

  

雷达关于浏览器兼容性的

2.错误分析维度



# 

## 一、背景

rrweb 全称 'record and replay the web'，是当下很流行的一个录制屏幕的开源库。与我们传统认知的录屏方式（如 WebRTC）不同的是，rrweb 录制的不是真正的视频流，而是一个记录页面 DOM 变化的 JSON 数组，因此不能录制整个显示器的屏幕，只能录制浏览器的一个页签。

## 二、基本使用

> [github.com/rrweb-io/rr…](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Frrweb-io%2Frrweb%2Fblob%2Fmaster%2Fguide.zh_CN.md "https://github.com/rrweb-io/rrweb/blob/master/guide.zh_CN.md")

```js
import rrweb from 'rrweb';

let events = [];

let stopFn = rrweb.record({
  emit(event) {
    events.push(event); // 将 event 存入 events 数组中
    if (events.length > 100) { // 当事件数量大于 100 时停止录制
      stopFn();
    }
  },
});

// rrweb 播放器回放
const replayer = new rrweb.Replayer(events);
replayer.play(); // 播放
```

[Demo 地址](https://link.juejin.cn/?target=https%3A%2F%2Fwww.rrweb.io%2Fdemo%2Fcheckout-form "https://www.rrweb.io/demo/checkout-form")

## 三、实现原理

### 3.1 包的组成

rrweb 主要由以下三个包构成：

#### 3.1.1 rrweb

主要提供了 `record` 和 `replay` 两个方法，`record` 负责从一开始录制 DOM 全量信息，到后面监听页面的变化（mutation），并将每次的变化 `emit` 出来传给开发用户。`replay` 负责将 `record` 录制的一系列 JSON 数据重组再回放出当时的页面内容。

#### 3.1.2 rrweb-snapshot

主要提供了 `record` 中用的两个方法：序列化 node 节点获得用于传递变化信息的 `serializeNodeWithId` 和获取页面快照的 `snapshot` ；此外还提供了 `replay` 中用到的一个方法：还原页面快照帮助构建回放 DOM 的 `rebuild`。

#### 3.1.3 rrweb-player

为 rrweb 设计了一套全新 UI 的播放器，可以实现拖拽进度条、调整播放速度等功能。

### 3.2 录制过程 record

整体思路：初始化时获取当前页面的全量快照，添加监听器监听页面不同类型的变化（比如 DOM 的变化以及鼠标、滚动以及页面 resize 等的变化），当以上这些变化（mutation）发生时，根据类型的不同分别进行不同的序列化处理，并将处理好的数据 emit 出来。序列化处理时，给每个序列化的 node 节点分配一个 ID，并维护一个从 ID 到 node 节点的映射以及一个 node 节点到序列化后 serializedNode 节点的映射。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/92d2aed9ccc24a89b5570aa3c6b34a51~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)

> **Q**：为什么需要序列化节点？直接用原生的 node 节点不行吗？  
> **A**：由于需要经过网络传输存储在后端，如果直接用 node 节点对象首先是无法通过网络传输（必须要序列化），其次后端也无法存储。因此需要设计出一种合适的（能完整表达一个节点的所有信息，如位置、属性等）数据结构来序列化节点。

#### 3.2.1 前置知识

[Node.nodeType](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2FNode%2FnodeType "https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType"): 代表 node 节点的不同类型，在 rrweb 中我们常用到的有 `ELEMENT_NODE`、`TEXT_NODE` 和 `DOCUMENT_NODE` 。

[双向链表](https://juejin.cn/post/7078915940418748430 "https://juejin.cn/post/7078915940418748430")

[MutationObserver](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FMutationObserver "https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver")：可以监视 DOM 树的变更，当发生变更时会调用传入构建函数的 callback。它最重要的特点是会批量异步处理 DOM 的变化，比如对于多个 `appendChild` 和 `removeChild` 会批量处理调用一次 callback。

#### 3.2.2 源码阅读

为了解主流程原理，对源码进行了大幅简化。首先从我们调用的 `rrweb.record` 方法进入：

```js
function wrapEvent(e) {
    return Object.assign(Object.assign({}, e), { timestamp : Date . now () } );
}

function record(options = {}) {
    let incrementalSnapshotCount = 0;
    wrappedEmit = ( e, isCheckout ) => {
        emit ( eventProcessor (e), isCheckout);
        if (exceedCount || exceedTime) {
 takeFullSnapshot ( true );
}
    };
    takeFullSnapshot = (isCheckout = false) => {
        wrappedEmit(wrapEvent({
            type: EventType.Meta,
            data: {
                href: window.location.href,
                width: getWindowWidth(),
                height: getWindowHeight(),
            },
        }), isCheckout);
        // 获取了文档的全量快照，同时维护了一个节点和 ID 的映射 mirror
        const node = snapshot ( document , {
            mirror,
            // ...
        });
        wrappedEmit ( wrapEvent ({
 type : EventType . FullSnapshot ,
            data: {
                node,
                initialOffset: {
                    // left: ,
                    // top: ,
                },
            },
        }));
    };
    const handlers = [];
    const  observe = ( doc ) => {
        return  initObservers ({
 mutationCb : ( m ) =>  wrappedEmit ( wrapEvent ({  type : EventType . IncrementalSnapshot ,  data : Object . assign ({ source : IncrementalSource . Mutation }, m), })),
 mousemoveCb : ( positions, source ) =>  wrappedEmit ( wrapEvent ({
 type : EventType . IncrementalSnapshot ,
                data : {
source,
positions,
},
})),
            // 其他监听器...
        }, hooks);
    };
    const  init = () => {
 takeFullSnapshot ();
handlers. push ( observe ( document ));
recording = true ;
};
 init ();
    return () => {
        handlers.forEach((h) => h());
        recording = false;
    };
}
```

`record` 中定义了多个关键的函数。`init` 中执行了 `takeFullSnapshot` 和 `observe(document)`：

-   `takeFullSnapshot` ：获取文档的全量快照，作为后面增量快照的基准。首先 emit 了一个 meta 信息，然后执行 `snapshot(document, {...})`，会遍历整个文档树，为每个节点创建一个唯一的 ID 并序列化，维护在 mirror 对象的映射中。mirror 中维护了一个 ID 到原生 node 节点的映射和一个原生 node 节点到序列化后的 serializedNode 的映射，后面所有对 DOM 的操作变化都会实时维护在这两个映射中。这个映射主要用在回放中，可以试想如果只在本地构建重组 DOM 树，可以直接用原生的 node 节点组装起来（直接利用原生 node 的自带属性，如`parentNode`、`nextSibling`、`previousSibling`等）；但是如果需要传递一系列增量快照到远端存储并试图重建时，就必须传递可以序列化的信息，必须要有 ID 和序列化后的节点信息，这样用每个节点的 ID 加上这个节点本身的一些信息（比如节点类型，属性等）就可以重新构建。最后 emit 一个 fullSnapshot 信息，将序列化好的整个 DOM 树当作参数。
-   `observe`：初始化各种监听器，以两种主要的变化举例：鼠标的移动和 DOM 的变化。它们都包了两层，第一层先通过 `wrapEvent` 封装一个带 `timestamp` 时间戳（用于后续还原播放时使用）的 payload，然后再执行`wrappedEmit` 函数，这个函数包装了外界传参进来的 `emit` 方法，也就是说带时间戳的 payload 会被作为入参传给 rrweb 使用的开发者所写的 `emit` 方法。

这些 payload 根据变化类型的不同会有各自的属性，来帮助播放时还原录制的现场，比如鼠标的移动就需要鼠标的位置信息：

```js
function initObservers(o, hooks = {}) {
    const mutationObserver = initMutationObserver(o, o.doc);
    const mousemoveHandler = initMoveObserver(o);
    // 其他监听器...
}

function initMoveObserver({ mousemoveCb, sampling, doc, mirror, }) {
    const threshold = typeof sampling.mousemove === 'number' ? sampling.mousemove : 50;
    const callbackThreshold = typeof sampling.mousemoveCallback === 'number'
        ? sampling.mousemoveCallback
        : 500;
    let positions = [];
    const wrappedCb = throttle((source) => {
        const totalOffset = Date.now() - timeBaseline;
        mousemoveCb (positions. map ( ( p ) => {
p. timeOffset -= totalOffset;
 return p;
}), source);
        positions = [];
    }, callbackThreshold);
    const updatePosition = throttle((evt) => {
        const target = getEventTarget(evt);
        const { clientX, clientY } = isTouchEvent(evt)
            ? evt.changedTouches[0]
            : evt;
        positions. push ({
 x : clientX,
 y : clientY,
 id : mirror. getId (target),
 timeOffset : Date . now () - timeBaseline,
});
        wrappedCb(typeof DragEvent !== 'undefined' && evt instanceof DragEvent
            ? IncrementalSource.Drag
            : evt instanceof MouseEvent
                ? IncrementalSource.MouseMove
                : IncrementalSource.TouchMove);
    }, threshold, {
        trailing: false,
    });

    // 使用 addEventListener 就可以实现
    const handlers = [
 on ( 'mousemove' , updatePosition, doc),
 on ( 'touchmove' , updatePosition, doc),
 on ( 'drag' , updatePosition, doc),
];
    return () => {
        handlers.forEach((h) => h());
    };
}
```

首先对几种鼠标变化添加 `addEventListener` 监听器，当发生变化时执行 `updatePosition` 函数把获得的 position 作为 `mousemoveCb` 函数的入参传出来，最终给到上文的 emit 方法。注意其中做了节流的处理，rrweb 支持用 sampling 属性来配置抽样的频率。

再来看看我们最关注的 DOM 变化是如何转换成增量快照的。和鼠标移动的处理方式一样，在 `initObservers` 函数中调用处理 mutation 的 `initMutationObserver` 函数，其中我们创造了一个 `MutationBuffer` 对象 `mutationBuffer` 并 init 用来存放每次的 DOM 变化，然后利用创造一个 `MutationObserver` 对象 `observer`，`observer` 观察文档所有内容的变化。

```js
function initMutationObserver(options, rootEl) {
    const mutationBuffer = new MutationBuffer(); // 存放本次变化有关的信息
    mutationBuffers.push(mutationBuffer);
    mutationBuffer.init(options);
    const observer = new MutationObserver(mutationBuffer.processMutations.bind(mutationBuffer));
    observer.observe(rootEl, {
        attributes: true,
        attributeOldValue: true,
        characterData: true,
        characterDataOldValue: true,
        childList: true,
        subtree: true,
    });
    return observer;
}
```

当变化发生时，执行 `mutationBuffer` 的一个方法 `processMutations`，mutation 的类型有三种：

-   characterData：纯文本类型的变动；
-   attributes：节点属性类的变动；
-   childList：节点的新增、删除和移动。

我们最关注第三类节点的变化：

```js
class MutationBuffer {
    constructor() {
        this.frozen = false;
        this.locked = false;
        this.removes = [];
        this.mapRemoves = [];
        this.addedSet = new Set();
        this.movedSet = new Set();
        this . processMutations = ( mutations ) => {
mutations. forEach ( this . processMutation );
 this . emit ();
};
        this.emit = () => {
            // ...
        };
        this.processMutation = (m) => {
        switch (m. type ) { // 判断mutation的类型
            case 'characterData': {
                // ...
            }
            case 'attributes': {
                // ...
            }
            case  'childList' : {
                m. addedNodes . forEach ( ( n ) =>  this . genAdds (n, m. target ));
m. removedNodes . forEach ( ( n ) => {
                    const nodeId = this.mirror.getId(n);
                    const parentId = isShadowRoot(m.target)
                        ? this.mirror.getId(m.target.host)
                        : this.mirror.getId(m.target);
                    if (isBlocked(m.target, this.blockClass, this.blockSelector, false) ||
                        isIgnored(n, this.mirror) ||
                        !isSerialized(n, this.mirror)) {
                        return;
                    }
                    else if (this.addedSet.has(m.target) && nodeId === -1) ;
                    else if (isAncestorRemoved(m.target, this.mirror)) ;
                    else if (this.movedSet.has(n) &&
                        this.movedMap[moveKey(nodeId, parentId)]) {
                        deepDelete(this.movedSet, n);
                    }
                    else {
                        this . removes . push ({
parentId,
 id : nodeId,
 isShadow : isShadowRoot (m. target ) && isNativeShadowDom (m. target )
? true
: undefined ,
});
                    }
                });
            }
        }
        };
        this . genAdds = ( n, target ) => {
            if ( this . mirror . hasNode (n)) {
 this . movedSet . add (n);
}
            else {
 this . addedSet . add (n);
}
 if (! isBlocked (n, this . blockClass , this . blockSelector , false ))
n. childNodes . forEach ( ( childN ) =>  this . genAdds (childN));
        };
    }
}
```

`mutationBuffer` 对象维护了两个集合：`addedSet`、`movedSet`，还有一个 `removes` 数组，用于处理三种节点的变化：

-   新增节点（`mutation.addedNodes`)： 直接添加到 `addedSet` 中，对于这个节点的 `childNodes` ****中每个子节点都去递归执行 `genAdds` 函数；
-   删除节点（`mutation.removedNodes`)： 由于 `MutationObserver` 批量异步处理的特性，如果本次变化中出现先增加 A 节点，再删除 A 节点，此次变化的 `addedNodes` 和 `removedNodes` 都会有 A 节点。按照处理顺序会先把该节点添加进 `addedSet` 中，再处理 `removedNodes` 时应该把它从 `addedSet` 中删掉。对于需要真正删掉之前已有节点的情况，我们在回放时只需要拿到它的父节点和被删除的节点本身，所以直接将它的父节点 ID 和它本身的 ID （由于是已有的节点，所以在我们的 mirror 映射中一定能找到对应的节点信息）存放到 `removes` 数组当中即可；
-   移动节点： 当我们的映射 `mirror` 中已经存在节点 n 时，代表本次 mutation 的节点之前就在我们的 DOM 结构中。移动产生的根本原因也一定是先 `removeChild`，再 `appendChild` 这个移除的节点到新的父节点下。因此在 `MutationObserver` 中会先产生一个 `mutation.removedNodes` 的记录，再产生一个 `mutation.addedNodes` 的记录。首先按照删除节点的逻辑，会存放该节点信息到 `removes` 数组中，然后到 `genAdds` ****函数中发现此节点在 mirror 映射中，因此属于移动的节点，添加到 `movedSet` 中，同样递归它的子节点执行 `genAdds` 函数。

**添加节点时使用集合 Set 的原因：**

以下两种操作会生成相同的 DOM 结构，但是产生不同的 mutation 记录：

-   会生成两条 mutation 记录，但是由于 MutationObserver 的批量异步处理特性，在第一条 mutation 记录中拿到的 n1 节点此时已经有 childNodes 了（即 n2 节点）；
-   只会产生一条 mutation 记录，即 n1 添加到父节点中，为了不落下 n2 节点，需要对这条 mutation 记录遍历它的所有子节点（上文新增节点中有提到）。

那么如果对于第一种情况，处理 n1 时遍历它的子节点添加了一次 n2，再处理第二条 mutation 记录 n2 节点时又会添加一遍，因此为了去重需要使用集合 Set。而删除节点则无需用集合，因为在回放 removeChild 时自然会把所有子节点都删掉。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c583171e26e74e1db48e03182d4da04a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)

在 `processMutations` 中，以上工作将本次回调的所有变动都收集好了，接下来继续执行 `emit` 方法：

**共识**：序列化节点的顺序应当是从位置能确定的节点（父节点和兄弟节点已经过序列化）开始。对于不确定的节点，需要先存储起来（ rrweb 就是利用了**双向链表**存储），待能确定后再序列化。

```js
this.emit = () => {
    if (this.frozen || this.locked) {
        return;
    }
    const adds = [];
    const addList = new  DoubleLinkedList ();
    const getNextId = (n) => {
        // 获取nextSibling的ID
    };
    const pushAdd = (n) => {
        if (!n.parentNode) {
            return;
        }
        const parentId = this.mirror.getId(n.parentNode);
        const nextId = getNextId(n);
        if (parentId === - 1 || nextId === - 1 ) {
 return addList. addNode (n);
}
        const sn = serializeNodeWithId (n, {
            // options...
        });
        if (sn) {
            adds. push ({
parentId,
nextId,
 node : sn,
});
        }
    };
    for (const n of Array.from(this.movedSet.values())) {
        if (isParentRemoved(this.removes, n, this.mirror) && !this.movedSet.has(n.parentNode)) {
            continue;
        }
        pushAdd(n);
    }
    for (const n of Array.from(this.addedSet.values())) {
        if (!isAncestorInSet(this.droppedSet, n) && !isParentRemoved(this.removes, n, this.mirror)) {
            pushAdd(n);
        }
        else if (isAncestorInSet(this.movedSet, n)) {
            pushAdd(n);
        }
        else {
            this.droppedSet.add(n);
        }
    }
    let candidate = null;
    while (addList.length) {
        let node = null;
        if (candidate) {
            const parentId = this.mirror.getId(candidate.value.parentNode);
            const nextId = getNextId(candidate.value);
            if (parentId !== -1 && nextId !== -1) {
                node = candidate;
            }
        }
        if (!node) {
            for (let index = addList. length - 1 ; index >= 0 ; index--) {
                const _node = addList.get(index);
                if (_node) {
                    const parentId = this.mirror.getId(_node.value.parentNode);
                    const nextId = getNextId(_node.value);
                    if (nextId === -1)
                        continue;
                    else if (parentId !== -1) {
                        node = _node;
                        break;
                    }
                }
            }
        }
        if (!node) {
            while (addList.head) {
                addList.removeNode(addList.head.value);
            }
            break;
        }
        candidate = node.previous;
        addList.removeNode(node.value);
        pushAdd(node.value);
    }
    const payload = {
 // 省略文本和属性部分代码
 removes : this . removes ,
adds,
};
 this . mutationCb (payload);
};
```

`emit` 方法最终会组合出一个代表本次 DOM 变化的 payload 传给 `mutationCb`（在 mutationBuffer init 时传入）执行，最终一路向上追溯到执行 rrweb 使用方所写的 `emit` 函数。

我们分析下是如何拿到这个 payload 的：

对于删除的节点，直接使用 `removes` 数组；对于新增（或移动）的节点，我们在回放时需要用到它的父节点、兄弟节点和它本身，定义 `adds` 数组存放新增的节点信息。首先遍历 `movedSet`，如果节点的父节点在本次回调中被删除了则不处理，否则执行 `pushAdd` 函数，然后遍历 `addedSet`，与 `movedSet` 处理相同。

在 `pushAdd` 函数中，**首先去获取当前被添加节点的父节点 ID 和下一相邻的兄弟节点 ID，如果发现父节点或者下一相邻节点尚未序列化（即尚未来得及维护 ID 加入 mirror 映射），将这个节点加入双向链表 `addList` 中（双向链表的 `addNode` 方法是按照 DOM 节点顺序来添加节点的，根据节点的 `previousSibling` 和 `nextSibling` 属性能找到前一兄弟节点的放到它后面，能找到后一兄弟节点的放到它前面，都找不到放到 head。也就是层级越深越靠前、同一层级按 DOM 顺序排位）先存储起来。** 如果能找到父节点 ID 和 下一相邻节点 ID 则对这个节点序列化 `serializeNodeWithId`，将序列化的节点和 `parentId` 以及 `nextId` 作为当前被添加节点的全部信息存到 `adds` 数组中。

处理完 `movedSet` 和 `addedSet` 后，遍历 `addList`，由于需要用到 `parentId` 和 `nextId` ，所以需要先序列化层级浅、同层级 DOM 顺序靠后的节点，也就是我们 `addList` 存储的相反顺序。所以从最后一个节点开始遍历 `addList` 双向链表，对每个节点执行 `pushAdd` 函数序列化（由于链表的最后一个节点 N 一定是没有下一兄弟节点的，所以在它执行 `pushAdd` 函数时可以走到序列化的步骤并添加它的有关信息到 `adds` 数组中，这样前一节点 N - 1 也可以拿到 N 的 ID）。

到这里所有被添加的节点也都处理完成了，`adds` 数组就是我们 payload 需要的，也就完成了**从一次 `mutationObserver` 回调的多条记录到一个 payload 中的文本、属性、添加节点信息、移除节点信息的转变**。

#### 3.2.3 举例

举一个稍微复杂的例子，按 1234 的顺序添加节点到 DOM 中：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ed0db7b0a9634d06b12824a3c61b45bc~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)

```js
function App() {
  useEffect(() => {
    record({
      emit(event) {
        if (event.data.source === 0) {
          console.log('events', event)
        }
      }
    });
  }, []);

  return (
    <div className="App">
      <div id='parent' />
      <button
        onClick={() => {
          const p = document.querySelector('#parent');
          const n1 = document.createElement('div');
          n1.id = '1';
          const n2 = document.createElement('div');
          n2.id = '2';
          const n3 = document.createElement('div');
          n3.id = '3';
          const n4 = document.createElement('div');
          n4.id = '4';
          p.appendChild(n1);
          p.appendChild(n2);
          n1.appendChild(n3);
          n1.appendChild(n4);
        }}
      >
        test
      </button>
    </div>
  );
}

```

observer 返回了四条 mutation 变化记录：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fe9f745c8b984e4eaf3f7a727ffcc00b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)

由于 MutationObserver 的批量异步处理方式，第一条新增的 n1 节点的 `childNodes` 已经有 n3 和 n4 节点了：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/50eb6bf48b8d4bc7bbaf52af163f2df2~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)

对于第一条 mutation 执行 `processMutation`，由于是新增节点会执行 `m.addedNodes.forEach((n) => this.genAdds(n, m.target));`。 `genAdds` 函数会对 n1 节点的子节点递归，所以第一次执行完 n1 节点时，`addedSet` 中已经存在了 n1 和它的两个子节点 n3、n4：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98f57d0e3c9846059fbea0a6bb40caac~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)

接下来执行第二条 mutation 即新增 n2 节点，执行完成后 `addedSet` 中就有全部四个新节点了：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d814f2cf9a734f609799d82b91919887~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)

最后执行第三、四条 mutation，但是 `addedSet` 不会有变化。

此时转化的第一步 `processMutation` 就完成了，继续第二步 `this.emit()` 转换成我们需要的 payload：

遍历 `addedSet`，先将 n1 节点取出执行 `pushAdd(n1)`，由于 n1 的 `nextSibling` n2 节点尚未序列化，需要先存储 n1 到双向链表 `addList` 的 head 位置待 n2 序列化后再处理。接着取 n3 节点执行 `pushAdd(n3)`，和 n1 一样，n3 的 `nextSibling` n4 节点尚未序列化，需要先存到 `addList` 中，按双向链表添加节点的规则，n3 的前一兄弟节点和后一兄弟节点都没有在双向链表中，所以需要将 n3 添加到 head 位置上，此时双向链表的结构是：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5665a8033df24395a8badc90d4cd8261~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)

接下来处理 n4 节点，虽然 n4 的 `nextSibling` 是 `null` （ nextId 也是 null ），但是它的父节点 n1 依然没有序列化（也暂存在双向链表中等待稍后序列化），所以 n4 也命中了 `if (`**`parentId === -1`**`|| nextId === -1)` 的判断需要存到链表中，由于 n4 的前一兄弟节点 n3 在链表头部，所以按照双向链表添加节点的规则需要将 n4 存到 n3 的后面，此时双向链表的结构是：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b4adf2bcab4749d9840d8c7b4f73407a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)

最后处理 n2 节点，由于 n2 的父节点是已经在 mirror 映射中的，所以能取到 `parentId`，它没有下一兄弟节点，所以 `nextId` 是 `null`，无需添加到链表中，可以直接序列化 `serializeNodeWithId(n2, {...})`，把序列化的结果以及 `parentId` 和 `nextId` 一起存到 `adds` 数组中。

对 `addedSet` 的四个节点遍历完成后，最后一步是倒序处理双向链表暂存的那些节点。最后一个节点是 n1，n1 的

`nextSibling` n2 已经序列化了，执行 `pushAdd(n1)`，能拿到 n1 的 `parentId` 和 `nextId`，直接序列化 `serializeNodeWithId(n1, {...})`，将拿到的序列化节点以及 `parentId` 和 `nextId` 一起存放到 `adds` 数组中。此时 `candidate` 指向 n1 的 previous 节点也就是 n4，和 n1 同样的处理方式，将序列化的 n4 节点以及 `parentId`（也就是刚刚序列化的 n1 节点的 ID）和 `nextId`（null）一起存到 `adds` 数组中。最后是 head 节点即 n3 节点，将序列化的 n3 以及`parentId`（n1 的 ID）和 `nextId`（null）一起存到 `adds` 数组中。

到这里双向链表中暂存的三个节点也处理完了，此时 `adds` 数组中保存了全部处理后的四个节点：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b1c9a33206024dbb99227e224fcb27a2~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)

依次是 n2、n1、n4 和 n3。组装好的 payload 如下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2784403e0e2a4519a654fab12d701a2a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)

最后经过一系列包装处理这个 payload 传递给使用者写的 emit 方法去执行，看到浏览器打印的信息如下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1ed322071beb42a1a69fdd18b4642ca3~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)

payload 基础上加一个 `source` 属性构成 `data` 字段，`source` 表示增量快照的类型，0 代表是 DOM 类的 Mutation，另外 `timestamp` 和 `type` 是所有 payload 都会包装的两个属性，`timestamp` 用于表示开始录屏到现在过了多久用于播放器回放，`type` 表示这个 `payload` 的类型，3 代表是增量快照，2 代表是全量快照。

```js
export enum EventType {
  DomContentLoaded,
  Load,
  FullSnapshot,
  IncrementalSnapshot,
  Meta,
  Custom,
  Plugin,
}
```

### 3.3 回放过程 replay

#### 3.3.1 前置知识

-   [XState](https://link.juejin.cn/?target=https%3A%2F%2Fxstate.js.org%2Fdocs%2Fzh%2F "https://xstate.js.org/docs/zh/")：有限状态机，通过各种不同的 action 管理状态的流转。
-   [requestAnimationFrame](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2Fwindow%2FrequestAnimationFrame "https://developer.mozilla.org/zh-CN/docs/Web/API/window/requestAnimationFrame")：告诉浏览器执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行。

#### 3.3.2 重建 DOM 流程

在回放过程中，播放器是用 XState 做状态管理的，有两个状态：播放 playing 和暂停 paused，初始状态是暂停。创建 Replayer 播放器实例时，会创建两个 service：`createPlayerService` 用于处理事件回放的逻辑，`createSpeedService` 用于控制播放速度。然后会用事件中的第一个全量快照来还原一个初始的 DOM 树作为后续添加增量快照变更的基础。与录屏时相同，对每个节点也要做序列化 `buildNodeWithSN` 并维护同样的 mirror 映射。在构建全量 DOM 树和后面处理增量快照时，都是结合目标节点本身、父节点和兄弟节点的信息来定位位置和属性，再调用 `appendChild`、`insertBefore`、`removeChild` 这几个 Node 节点的方法（或者其他处理节点属性的方法）。调用 replayer 实例上的 `play` 方法就开始按时间顺序还原增量快照了，会向 playerService 派发 `'PLAY'` 事件，此时状态机就从初始的 paused 转变为 playing。当调用 replayer 实例上的 `pause` 方法时，会向 playerService 派发 `'PAUSE'` 事件，此时状态由 playing 转变为 paused。

回放重建 DOM 与录屏时的区别是：录屏时先对 DOM 做改动再产出序列化节点，回放重建是先根据 event 序列化节点，再改动 DOM 结构。两者各自都随时维护着一个 mirror 映射。

#### 3.3.3 播放器

rrweb 的播放器是在一个 `iframe` 上回放录屏的，为了阻断 `iframe` 上的用户交互需要做一些特殊处理，比如在 `iframe` 标签上设置 CSS 属性：

```undefined
pointer-events: none;
```

为了去脚本化，将 `<script>` 标签替换为 `<noscript>` 标签，另外将 `iframe` 的 `sandbox` 属性设置为 “allow-same-origin”，可以防止任何脚本的执行。

播放器的进度条是如何控制与每个增量快照发生的时间对应上呢？

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/07120cf184164421a61274b1580988d5~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)

比如在播放时用户点击进度条上的某一点，这一点距离初始时间点是 timeOffset 长度，点击的这个点可以叫做基线时间点 baselineTime，rrweb 会根据这个点将所有的事件分成两部分：前一部分是在基线时间点前已经发生的事件队列，后一部分是待回放的事件队列。把前一部分事件同步还原构建完成，作为后面队列的全量基准 DOM 树，再继续异步地按照正确的时间间隔构建后面的增量快照。

rrweb 借助 `requestAnimationFrame` 实现了一个高精度的计时器 `Timer`。上面介绍待回放的事件队列会被加到定时器的 actions 中，当每次`requestAnimationFrame` 调用回调函数 `check` 时，会判断当前时间与下一个待回放事件的时间先后顺序，如果发现当前时间大于等于下一事件的播放时间了，就去 `doAction` 执行它，确保绝大部分情况下增量快照的重放延迟不超过一帧。

```js
public start() {
  this.timeOffset = 0;
  let lastTimestamp = performance.now();
  const  check = () => {
    const time = performance.now();
    this.timeOffset += (time - lastTimestamp) * this.speed;
    lastTimestamp = time;
    while (this.actions.length) {
      const action = this.actions[0];
      if ( this . timeOffset >= action. delay ) {
 this . actions . shift ();
action. doAction ();
      } else {
        break;
      }
    }
    if ( this . actions . length > 0 || this . liveMode ) {
 this . raf = requestAnimationFrame (check);
}
  };
  this . raf = requestAnimationFrame (check);
}
```

## 四、与 WebRTC 对比

|                        | **rrweb**                                  | **WebRTC**                         |
| ---------------------- | ------------------------------------------ | ---------------------------------- |
| 录制显示器上的完整信息 | 仅能录制当前浏览器 TAB 页                  | ✅                                  |
| 用户无感知录制         | ✅                                          | 需要用户同意并选择录制的屏幕内容   |
| 录制内容大小           | 均为 JSON 数据，且页面无变动时不会增加大小 | 与录制时间成正比，占据存储空间较大 |
| 播放器                 | 提供了一套独立设计的播放器，功能完整       | 需自行寻找合适的播放器             |
| 回放视频清晰度         | 完全还原 DOM 结构                          | 清晰度会有损失                     |

## 五、插件优化

`sentry-rrweb` 是基于 `rrweb` 和 `Sentry` 的集成插件，它的主要作用是将 `rrweb` 录制的回放数据与 Sentry 事件（如崩溃或错误日志）结合，实现更好的问题复现能力。

如果你要优化这个插件，可以从以下几个方面入手：

------

## **1. 录制性能优化**

### **(1) 降低录制频率**

默认情况下，`rrweb` 可能会频繁记录 DOM 变化，导致较大的回放数据。你可以通过 `recordOptions` 选项调整：

```js
import { record } from 'rrweb';

const stopFn = record({
  emit(event) {
    // 处理事件
  },
  sampling: {
    // 降低鼠标移动的录制频率
    mousemove: false, // 关闭鼠标移动
    mousemoveCallback: 100, // 降低鼠标事件回调频率
    scroll: 150, // 记录滚动事件间隔，单位 ms
    input: 'last', // 只记录最后一次输入变化
  },
});
```

### **(2) 忽略不必要的 DOM 变化**

可以忽略不重要的 DOM 变化，比如某些动画、鼠标 hover 等：

```js
const stopFn = record({
  emit(event) {
    if (event.type === 4) return; // 忽略鼠标移动事件
  },
  maskAllInputs: true, // 避免记录用户输入
});
```

------

## **2. 降低数据上传大小**

### **(1) 启用 gzip 压缩**

你可以在 Sentry 服务器端或者浏览器端使用 `gzip` 压缩：

```js
import { gzip } from 'pako';

function sendCompressedEvent(event) {
  const compressedData = gzip(JSON.stringify(event));
  fetch('/api/logs', {
    method: 'POST',
    body: compressedData,
    headers: { 'Content-Encoding': 'gzip' },
  });
}
```

这样可以大幅减少 Sentry 事件的体积。

### **(2) 过滤无关日志**

在 `Sentry.init` 里添加 `beforeSend` 过滤无用事件：

```js
Sentry.init({
  dsn: 'your-dsn',
  integrations: [new SentryRRWeb()],
  beforeSend(event) {
    if (event.message?.includes('ResizeObserver loop limit exceeded')) {
      return null; // 忽略不必要的错误
    }
    return event;
  },
});
```

------

## **3. 提高回放体验**

### **(1) 事件关联增强**

默认情况下，Sentry 可能只存储部分事件信息，你可以在 `beforeSend` 里手动添加 `rrweb` 相关事件：

```js
Sentry.configureScope((scope) => {
  scope.setExtra('sessionReplay', rrwebEvents);
});
```

这样，Sentry 上的错误报告能更准确地还原用户操作。

### **(2) 让 Sentry 只上传关键回放片段**

完整回放数据可能太大，可以只上传用户交互前后的片段：

```js
const eventsBuffer = [];
record({
  emit(event) {
    eventsBuffer.push(event);
    if (eventsBuffer.length > 100) eventsBuffer.shift(); // 只保留最近 100 个事件
  },
});
Sentry.captureException(new Error('用户错误'), (event) => {
  event.extra = { replayEvents: eventsBuffer };
  return event;
});
```

------

## **4. 使用 Flashbots Bundle (MEV 相关)**

如果你希望在 Web3 交易中集成 `sentry-rrweb` 进行前端数据追踪，并结合 MEV 保护策略（如 Flashbots Bundle），可以：

- 在 `beforeSend` 里手动添加交易哈希
- 通过 `extra` 传递用户交易的相关 `metadata`

```js
Sentry.captureException(new Error('交易失败'), (event) => {
  event.extra = {
    transactionHash: '0x123...',
    mevProtection: 'Flashbots',
  };
  return event;
});
```

------

### **总结**

- **录制优化**：降低 `rrweb` 录制频率，忽略不必要 DOM 变化
- **数据优化**：启用 Gzip 压缩，过滤无用日志
- **回放优化**：手动关联 `rrweb` 数据，减少上传体积
- **Web3 结合**：增加 Flashbots 交易追踪

这样可以提升 `sentry-rrweb` 的性能，并减少数据存储和带宽消耗。🚀



为了保证 `sentry-rrweb` 录屏的完整性，你需要从 DOM 采集的角度优化数据捕获，确保不会漏掉关键用户操作和页面变化。以下是几个关键优化点：

------

## **1. 确保初始 DOM 捕获完整**

`rrweb` 在录制时，第一次快照 (`fullSnapshot`) 是最重要的，因为它决定了后续的增量更新是否有效。你可以手动确保初始化时完整捕获：

### **(1) 在页面稳定后再开始录制**

如果 `rrweb` 过早开始录制，可能会遗漏某些延迟加载的 DOM 内容。可以使用 `MutationObserver` 确保页面稳定后再启动：

```js
function waitForPageStable(callback) {
  const observer = new MutationObserver(() => {
    if (document.readyState === 'complete') {
      observer.disconnect();
      callback();
    }
  });
  observer.observe(document, { childList: true, subtree: true });
}

waitForPageStable(() => {
  record({ emit(event) { /* 处理事件 */ } });
});
```

这样可以避免在页面加载过程中漏掉重要的 `DOM` 结构。

------

## **2. 监听 Shadow DOM**

现代前端框架（如 Web Components）可能会使用 `Shadow DOM`，而 `rrweb` 默认不监听它们。你需要手动监听 `shadowRoot` 的变更：

```js
function observeShadowRoots(node) {
  if (node.shadowRoot) {
    record({ emit(event) { /* 处理 Shadow DOM 事件 */ }, packShadowRoot: true });
  }
}

const observer = new MutationObserver((mutations) => {
  mutations.forEach((mutation) => {
    mutation.addedNodes.forEach((node) => {
      if (node.nodeType === 1) { // ELEMENT_NODE
        observeShadowRoots(node);
      }
    });
  });
});

observer.observe(document, { childList: true, subtree: true });
```

这样可以保证 `Shadow DOM` 里的内容也能被 `rrweb` 记录。

------

## **3. 监听 `iframe`**

`iframe` 里的内容默认不会被 `rrweb` 录制，导致录屏缺失。你需要手动监听 `iframe`：

```js
document.querySelectorAll('iframe').forEach((iframe) => {
  try {
    iframe.contentWindow.record({
      emit(event) {
        event.extra = { fromIframe: true };
        // 处理 iframe 事件
      },
    });
  } catch (e) {
    console.warn('无法访问 iframe:', e);
  }
});
```

这样 `iframe` 内的变化也能被捕获。

------

## **4. 解决动态加载和延迟渲染问题**

现代前端框架（如 `Vue` 和 `React`）可能会延迟渲染某些 DOM，导致 `rrweb` 初次快照缺失。可以监听 `MutationObserver`：

```js
const observer = new MutationObserver((mutations) => {
  mutations.forEach((mutation) => {
    mutation.addedNodes.forEach((node) => {
      if (node.nodeType === 1) { // 只监听元素节点
        record({ emit(event) { /* 处理新元素 */ } });
      }
    });
  });
});

observer.observe(document.body, { childList: true, subtree: true });
```

这样当 `Vue` 或 `React` 组件异步加载时，也能正确记录。

------

## **5. 监听 CSS 动画和过渡**

`rrweb` 默认不会捕获 CSS 动画，所以如果页面中有 `transition` 或 `animation`，可以手动监听：

```js
document.addEventListener('animationstart', (event) => {
  record({ emit() { /* 记录动画开始 */ } });
});

document.addEventListener('transitionstart', (event) => {
  record({ emit() { /* 记录过渡效果 */ } });
});
```

这样可以确保动画效果也能回放。

------

## **6. 监听用户输入**

默认情况下，`rrweb` 可能不会记录某些复杂输入（如 `contenteditable` 区域）。可以手动监听：

```js
document.querySelectorAll('[contenteditable]').forEach((el) => {
  el.addEventListener('input', (event) => {
    record({ emit() { /* 记录输入变化 */ } });
  });
});
```

这样 `contenteditable` 区域的文本输入也能被捕获。

------

## **7. 防止事件丢失**

有时候 `rrweb` 可能会在 `record()` 启动前丢失事件，解决方法是：

- **提前缓存事件**
- **延迟 `record()` 启动**

```js
const eventBuffer = [];

document.addEventListener('click', (event) => {
  eventBuffer.push(event);
});

setTimeout(() => {
  record({ emit(event) { eventBuffer.push(event); } });
}, 1000);
```

这样可以确保在 `record()` 启动前的事件不会丢失。

------

## **总结**

| 问题                             | 解决方案                                                |
| -------------------------------- | ------------------------------------------------------- |
| 页面加载未完成时 `DOM` 缺失      | 等待 `MutationObserver` 监听页面稳定后再启动 `record()` |
| `Shadow DOM` 里的内容丢失        | 监听 `shadowRoot` 变化并手动启用 `record()`             |
| `iframe` 内部内容未记录          | 手动在 `iframe` 内部初始化 `record()`                   |
| Vue/React 异步渲染的内容丢失     | 监听 `MutationObserver` 变化并重新 `record()`           |
| CSS 动画和过渡未记录             | 监听 `animationstart` 和 `transitionstart` 事件         |
| `contenteditable` 里的输入未记录 | 监听 `input` 事件手动捕获                               |
| 启动 `record()` 前的事件丢失     | 先缓存事件，再延迟启动 `record()`                       |

| 问题                               | 解决方案                                              |
| ---------------------------------- | ----------------------------------------------------- |
| `DOM` 采集不完整                   | `requestIdleCallback` 等待页面稳定后再启动 `record()` |
| 懒加载元素未被记录                 | `IntersectionObserver` 监听进入视口的元素             |
| `canvas` & `WebGL` 变化未被记录    | 拦截 `fillRect()`、`drawArrays()` 事件                |
| `fetch` & `WebSocket` 交互未被记录 | 拦截 `window.fetch()` 和 `WebSocket.send()`           |
| 页面切换导致录制中断               | `visibilitychange` 事件监听                           |
| `resize` 影响回放                  | `ResizeObserver` 监听窗口大小变更                     |
| 滚动位置未恢复                     | `scroll` 事件监听                                     |
| 组合键未被捕获                     | `keydown` 事件监听                                    |

通过这些优化，可以保证 `sentry-rrweb` 录屏的完整性，最大程度还原用户操作！🚀

### **如何确定 `sentry-rrweb` 录制的时间范围？**

为了合理确定 `sentry-rrweb` 录制的时间范围，需要根据实际应用的需求设置合适的 **起点** 和 **终点**。以下是几种常见的策略：

------

## **1. 设定固定的录制时间范围**

### **(1) 设定固定时长（如 5 分钟）**

如果希望 `rrweb` 仅录制 **最近 N 分钟** 的用户行为，可以限制事件缓冲区的大小：

```js
const maxDuration = 5 * 60 * 1000; // 5 分钟
let eventBuffer = [];
let startTime = Date.now();

record({
  emit(event) {
    const now = Date.now();
    eventBuffer.push({ event, timestamp: now });

    // 只保留最近 5 分钟的事件
    eventBuffer = eventBuffer.filter(e => now - e.timestamp <= maxDuration);
  }
});
```

**✅ 适用场景**：希望保留最近一段时间的用户操作，而不是完整的会话。

------

## **2. 以用户行为为触发点**

### **(2) 在用户点击关键操作时启动**

如果你希望 `rrweb` 只在特定用户操作（如点击“提交”按钮）时开始录制：

```js
let isRecording = false;
let stopRecording = null;

document.getElementById('start-btn').addEventListener('click', () => {
  if (!isRecording) {
    isRecording = true;
    stopRecording = record({
      emit(event) { /* 处理事件 */ }
    });
  }
});

document.getElementById('stop-btn').addEventListener('click', () => {
  if (isRecording) {
    isRecording = false;
    stopRecording && stopRecording(); // 停止录制
  }
});
```

**✅ 适用场景**：用户需要手动触发录制，比如表单提交前后。

------

## **3. 监听关键事件自动启动和结束**

### **(3) 仅在用户发生异常时回溯录制**

结合 `Sentry`，当检测到 `JavaScript` 错误时，回溯录制最近 `N` 秒的数据：

```js
const maxDuration = 60 * 1000; // 只保留最近 60 秒
let eventBuffer = [];

record({
  emit(event) {
    eventBuffer.push({ event, timestamp: Date.now() });
    eventBuffer = eventBuffer.filter(e => Date.now() - e.timestamp <= maxDuration);
  }
});

// 当异常发生时，将事件记录到 Sentry
window.onerror = function (message, source, lineno, colno, error) {
  Sentry.captureException(error, {
    extra: {
      replayEvents: eventBuffer.map(e => e.event)
    }
  });
};
```

**✅ 适用场景**：仅在发生错误时回溯关键操作，避免浪费存储空间。

------

## **4. 监听 `visibilitychange` 事件**

### **(4) 仅在用户活跃时录制**

为了避免录制无效数据，可以只在用户可见 `tab` 时启动：

```js
let stopRecording = null;

document.addEventListener('visibilitychange', () => {
  if (document.hidden) {
    stopRecording && stopRecording(); // 停止录制
    stopRecording = null;
  } else {
    if (!stopRecording) {
      stopRecording = record({
        emit(event) { /* 处理事件 */ }
      });
    }
  }
});
```

**✅ 适用场景**：希望避免录制用户离开页面的情况，提高存储效率。

------

## **5. 限制最大录制时长**

### **(5) 在达到最大时长时自动停止**

如果不希望录制过长的会话，可以设置最长录制时间：

```js
const maxRecordingTime = 10 * 60 * 1000; // 最长 10 分钟
let stopRecording = record({
  emit(event) { /* 处理事件 */ }
});

setTimeout(() => {
  stopRecording && stopRecording();
}, maxRecordingTime);
```

**✅ 适用场景**：适合长时间会话但仍希望限制数据大小的情况。

------

## **6. 按照会话自动管理**

### **(6) 在用户空闲后自动结束录制**

可以监听用户的活动，如果用户一段时间未操作，就自动停止录制：

```js
let stopRecording = record({
  emit(event) { /* 处理事件 */ }
});

let inactivityTimer;
document.addEventListener('mousemove', resetInactivityTimer);
document.addEventListener('keydown', resetInactivityTimer);

function resetInactivityTimer() {
  clearTimeout(inactivityTimer);
  inactivityTimer = setTimeout(() => {
    stopRecording && stopRecording();
  }, 5 * 60 * 1000); // 5 分钟无操作后停止
}
```

**✅ 适用场景**：自动检测用户是否活跃，避免录制无意义数据。

------

## **7. 结合后端逻辑**

### **(7) 后端决定录制的时间范围**

如果 `Sentry` 服务器端存储 `rrweb` 事件，可以通过 `API` 控制前端的录制时间：

```js
fetch('/api/get-recording-settings')
  .then(res => res.json())
  .then(data => {
    if (data.shouldRecord) {
      record({
        emit(event) { /* 处理事件 */ }
      });
    }
  });
```

**✅ 适用场景**：后台动态控制录制策略，比如只有付费用户才开启录制。

------

## **总结**

| 方案                   | 适用场景                                |
| ---------------------- | --------------------------------------- |
| **固定录制时间**       | 适合希望记录最近 `N` 分钟操作的场景     |
| **手动控制录制**       | 适合用户明确希望开始/结束录制的情况     |
| **错误发生时回溯录制** | 仅在发生错误时回溯最近 `N` 秒的用户操作 |
| **页面可见时录制**     | 避免录制用户离开 `tab` 的无效数据       |
| **最大录制时长**       | 避免长时间录制导致存储空间消耗过大      |
| **用户空闲后停止录制** | 适用于需要检测用户活跃度的场景          |
| **后端控制录制策略**   | 适用于需要动态调整录制规则的场景        |

如果你的目标是 **降低存储压力**，推荐 **错误发生时回溯录制** 或 **用户空闲后停止录制**。如果希望 **尽量完整地记录用户行为**，可以选择 **固定时长录制** + **最大录制时长限制** 结合使用。

你可以根据具体需求选择合适的方法来确定 `sentry-rrweb` 录制的时间范围！🚀

## 参考资料：

[状态机系列 (一) : 令人头疼的状态管理](https://link.juejin.cn/?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F406551473 "https://zhuanlan.zhihu.com/p/406551473")

[rrweb 录屏原理浅析](https://link.juejin.cn/?target=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000041657578 "https://segmentfault.com/a/1190000041657578")

[rrweb 带你还原问题现场](https://link.juejin.cn/?target=https%3A%2F%2Fmusicfe.com%2Frrweb%2F "https://musicfe.com/rrweb/")
