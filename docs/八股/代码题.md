# 代码题

## 手写题

### 1.手写防抖函数

**非立即防抖**

非立即执行函数： 多次触发事件，只会在最后一次触发事件后等待设定的wait时间结束时执行一次

```js
function debounce(fn,delay) {
  let timer = null
  return function(...args) {
    clearTimeout(timer)
    timer = null
    timer = setTimeout(() => {
      fn.apply(this,args)
    },delay)
  }
}
function task(){
	console.log('run task')
}
const debounceTask=debounce(task,1000)
window.addEventListener('scroll',debounceTask);
```

**立即防抖**

立即执行：即多次触发事件，第一次会立即执行函数，之后在设定wait事件内触犯的事件无效，不会执行。

设置clearTimeout为什么还要timer=null
设置延时器之前先清除下延时器，不然每次事件触发都会多一个延时器，延时器之间互相干扰，造成紊乱。

```js
function debounce(fn,delay){
	let timer;
	return function(...args){
		if(timer){
			clearTimeout(timer);
      timer=null;
		}
		timer=setTimeout(()=>{
     // 获取函数的作用域和变量
			fn.apply(this,args)
		},delay);
	}
}
//测试
function task(){
	console.log('run task')
}
const debounceTask=debounce(task,1000)
window.addEventListener('scroll',debounceTask);
```

### 2.手写节流函数

**非立即节流**  连续点击的话，每过 wait 秒执行一次

```js
function throttle(fn, time) {
	let timer = null
	return function (...args) {
		if (!timer) {
			timer = setTimeout(() => {
				fn.apply(this,args)
				timer = null
			}, time)
		}
	}
}
```



```js
function throttle(fn, wait) {
  let timer = true
  return function(...args) {
    if(!timer) return
    timer = false
    setTimeout(() => {
      // fn() // fn中this指向window
      fn.apply(this,args) // fn中this指timer  下面同理
      console.log(this)
      timer = true
    }, wait)
  }
}
function task(){
	console.log('run task')
}
const throttleTask=throttle(task,1000);
window.addEventListener('scroll',throttleTask);
```

**立即节流** 连续点击的话，第一下点击会立即执行一次 然后每过 wait 秒执行一次

```js
function throttle(fn,delay){
	let last=Date.now();
	return function(...args){
		const now =Date.now();
		if(now-last>delay){
			last=now;
			fn.apply(this,args)
      console.log(this)
		}
	}
}
function task(){
	console.log('run task')
}
const throttleTask=throttle(task,1000);
window.addEventListener('scroll',throttleTask);
```



### 3.手写浅拷贝深拷贝

浅拷贝是指，一个新的对象对原始对象的属性值进行精确地拷贝，如果拷贝的是基本数据类型，拷贝的就是基本数据类型的值，如果是引用数据类型，拷贝的就是内存地址。如果其中一个对象的引用内存地址发生改变，另一个对象也会发生变化。

#### 浅拷贝

##### Object.assign()

Object.assign() 是ES6中对象的拷贝方法，接受的第一个参数是目标对象，其余参数是源对象，用法： Object.assign(target, source1, ···) ，该方法可以实现浅拷贝，也可以实现一维对象
的深拷贝。

```js
let target = {a: 1};
let object2 = {b: 2};
let object3 = {c: 3};
Object.assign(target,object2,object3);
console.log(target); // {a: 1, b: 2, c: 3}
```

##### 扩展运算符

使用扩展运算符可以在构造字面量对象的时候，进行属性的拷贝。语法： let cloneObj = {...obj };

```js
let obj1 = {a:1,b:{c:1}
let obj2 = {...obj1};
obj1.a = 2;
console.log(obj1); 
//{a:2,b:{c:1}}
console.log(obj2);
//{a:1,b:{c:1}}
obj1.b.c = 2;
console.log(obj1); 
//{a:2,b:{c:2}}
console.log(obj2); 
//{a:1,b:{c:2
```

##### 数组方法实现数组浅拷贝

###### Array.prototype.slice()

array.slice(start, end)

从已有数组中返回选定的元素，该方法有两个参数，两个参数都可选，如果两个参数都不写，就可以实现一个数组的浅拷贝

###### Array.prototype.concat()

concat() 用于合并两个或多个数组  返回一个新数组

##### 手写浅拷贝

```js
function shallowCopy(object){
		if(!object||typeof object!=="object") return
  	let newObject=Array.isArray(object)?[]:{}
    for(let key in object){
      if(object.hasOwnProperty(key)){
        newObject[key]=object[key]
      }
    }
  return newObject
}
```



#### 深拷贝

##### JSON.stringify()

`JSON.parse(JSON.stringify(obj))`   原理就是利用
`JSON.stringify` 将 js 对象序列化（JSON字符串），再使用`JSON.parse` 来反序列化(还原)js 对象

拷贝的对象中如果有函数，undefined，
symbol，当使用过 JSON.stringify() 进行处理之后，都会消失

```js
let obj1 = { a: 0,b: {c: 0}};
let obj2 = JSON.parse(JSON.stringify(obj1)
obj1.a = 1;
obj1.b.c = 1;
console.log(obj1); // {a: 1, b: {c: 1}}
console.log(obj2); // {a: 0, b: {c: 0}}
```



##### 手写深拷贝

没有处理 null 这种原始类型，也没有日期和正则这种比较常用的引用类型

```js
 function clone(target) {
    if (typeof target === 'object') {
        let cloneTarget = Array.isArray(target) ? [] : {};
        for (const key in target) {
            cloneTarget[key] = clone(target[key]);
        }
        return cloneTarget;
    } else {
        return target;
    }
};

let obj={
    a:function(){
        console.log('a')
    },
    b:{
        c:'d'
    },
   d:[1,2,3,4],
  e: new Date(),
  f: /abc/,
  g: null
}
console.log(clone(obj));
```

处理 日期 正则 null

```js
function deepClone (target) {
  if (target === null) return target // 处理 null
  if (target instanceof Date) return new Date(target) // 处理日期
  if (target instanceof RegExp) return new RegExp(target) // 处理正则
  
  if (typeof target !== 'object') return target // 处理原始类型
  
  // 处理对象和数组
  //const cloneTarget = new target.constructor() //创建一个新的克隆对象或克隆数组  不用在拷贝时去判断数组类型了
 const cloneTarget = Array.isArray(target) ? [] : {};
  for (const key in target) { // 递归拷贝每一层
    cloneTarget[key] = deepClone(target[key]) 
  }
  return cloneTarget
}
let obj={
    a:function(){
        console.log('a')
    },
    b:{
        c:'d'
    },
   d:[1,2,3,4],
  e: new Date(),
  f: /abc/,
  g: null
}
console.log(deepClone(obj));
```



```js
function deepClone(obj) {
        let result;
        if (typeof obj == "object") {
          if (obj == null) {
            result = obj;
          } else if (obj instanceof RegExp) {
            result = new RegExp(obj);
          } else if (obj instanceof Date) {
            result = new Date(obj);
          } else if (Array.isArray(obj)) {
            result = [];
            for (let key of obj) {
              result.push(deepClone(key));
            }
          } else {
            result = {};
            for (let key in obj) {
              if (!result.hasOwnProperty(key)) {
                result[key] = deepClone(obj[key]);
              }
            }
          }
        } else {
          result = obj;
        }
        return result;
      }
      let m = {
        a: 1,
        b: ["name", "xxx"],
        c: /^g/,
        d: { e: 1 },
        f: function (a, b) {
          console.log(666);
        },
      };

      console.log(deepClone(m));
```



##### 解决循环引用和symbol

```js
const obj = {
	name: "cc",
	age: 30,
	job: { type: "porgrammer", com: "ali" },
	cars: ["passat", "bmw"],
	working: function (str) {
		console.log(`我是${this.name},我正在${str}`)
	},
	da: new Date(),
	reg: new RegExp(),
	xx: undefined ,
};
obj.f=obj

function clone(obj, map = new Map()) {
	if (typeof obj != 'object') return
	var newObj = Array.isArray(obj) ? [] : {}
	if (map.get(obj)) {
		return map.get(obj);
	}
	map.set(obj, newObj);
	for (var key in obj) {
		if (obj.hasOwnProperty(key)) {
			if (typeof obj[key] == 'object') {
				newObj[key] = clone(obj[key], map);
			} else {
				newObj[key] = obj[key];
			}
		}
	}
	return newObj;
}

var copyobj = clone(obj)
console.log(copyobj);

```

可以把 `for in` 换成 `Reflect.ownKeys` 来解决


Reflect.ownKeys方法返回一个由目标对象自身的属性键组成的数组。它的返回值等同于Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target))


```js
// 终极解决方案，满足循环引用和symbol
//判断是否是基本数据类型
function isPrimitive(value){
  return (typeof value === 'string' || 
  typeof value === 'number' || 
  typeof value === 'symbol' ||
  typeof value === 'boolean')
}
 
//判断是否是一个js对象
function isObject(value){
  return Object.prototype.toString.call(value) === "[object Object]"
}
 
//深拷贝一个值
function cloneEnDeep(value){
  // 记录被拷贝的值，避免循环引用的出现
    let memo = {};
    function baseClone(value){
        let res;
        // 如果是基本数据类型，则直接返回
        if(isPrimitive(value)){
            return value;
        // 如果是引用数据类型，我们浅拷贝一个新值来代替原来的值
        }else if(Array.isArray(value)){
            res = [...value];
        }else if(isObject(value)){
            res = {...value};
        }
 
        // 检测我们浅拷贝的这个对象的属性值有没有是引用数据类型。如果是，则递归拷贝
        //同时使用Reflect可以检测到Symbol类型的属性
        Reflect.ownKeys(res).forEach(key=>{
            if(typeof res[key] === "object" && res[key]!== null){
                //此处我们用memo来记录已经被拷贝过的引用地址。以此来解决循环引用的问题
                if(memo[res[key]]){
                res[key] = memo[res[key]];
                }else{
                memo[res[key]] = res[key];
                res[key] = baseClone(res[key])
                }
            }
        })
        return res;  
    }
    return baseClone(value)
}
 
//======================测试====================
 //定义一个员工个人对象
 let objP = {
            name:"cc",
            age:30,
            job:{type:"porgrammer",com:"ali"},
            cars:["passat","bmw"],
            working:function(str){
                console.log(`我是${this.name},我正在${str}`)
            },
            da:new Date(),
            reg: new RegExp(),
            xx:undefined
        }
 
objP.job = objP;//循环引用
console.log(obj);
console.log(getPerInf(obj));
console.log(obj);
obj.working("吃饭");
```

完全版

支持对象、数组、日期、正则的拷贝。

处理原始类型（原始类型直接返回，只有引用类型才有深拷贝这个概念）。

处理 Symbol 作为键名的情况。

处理函数（函数直接返回，拷贝函数没有意义，两个对象使用内存中同一个地址的函数，问题不大）。

处理 DOM 元素（DOM 元素直接返回，拷贝 DOM 元素没有意义，都是指向页面中同一个）。

额外开辟一个储存空间 WeakMap，解决循环引用递归爆栈问题（引入 WeakMap 的另一个意义，配合垃圾回收机制，防止内存泄漏）。

```js
function deepClone (target, hash = new WeakMap()) { // 额外开辟一个存储空间WeakMap来存储当前对象
  if (target === null) return target // 如果是 null 就不进行拷贝操作
  if (target instanceof Date) return new Date(target) // 处理日期
  if (target instanceof RegExp) return new RegExp(target) // 处理正则
  if (target instanceof HTMLElement) return target // 处理 DOM元素

  if (typeof target !== 'object') return target // 处理原始类型和函数 不需要深拷贝，直接返回

  // 是引用类型的话就要进行深拷贝
  if (hash.get(target)) return hash.get(target) // 当需要拷贝当前对象时，先去存储空间中找，如果有的话直接返回
  const cloneTarget = new target.constructor() // 创建一个新的克隆对象或克隆数组
  hash.set(target, cloneTarget) // 如果存储空间中没有就存进 hash 里

  Reflect.ownKeys(target).forEach(key => { // 引入 Reflect.ownKeys，处理 Symbol 作为键名的情况
    cloneTarget[key] = deepClone(target[key], hash) // 递归拷贝每一层
  })
  return cloneTarget // 返回克隆的对象
}


const obj = {
  a: true,
  b: 100,
  c: 'str',
  d: undefined,
  e: null,
  f: Symbol('f'),
  g: {
    g1: {} // 深层对象
  },
  h: [], // 数组
  i: new Date(), // Date
  j: /abc/, // 正则
  k: function () {}, // 函数
  l: [document.getElementById('foo')] // 引入 WeakMap 的意义，处理可能被清除的 DOM 元素
}

obj.obj = obj // 循环引用

const name = Symbol('name')
obj[name] = 'lin'  // Symbol 作为键

const newObj = deepClone(obj)

console.log(newObj)

```



### 4.手写ajax

1.  创建 XMLHttpRequest 实例
2.  发出 HTTP 请求
3.  接收服务器传回的数据
4.  更新网页数据

```js
function handleGet(url) {
        var response = "";
        //1.创建对象
        var xhr = new XMLHttpRequest();
        //2.设置方法
        xhr.open("GET", url);
        //3.发送请求
        xhr.send();
        //4.返回结果
        xhr.onreadystatechange = function () {
          if (xhr.readyState == 4) {
            if (xhr.status >= 200 && xhr.status < 300) {
              response = xhr.responseText;
              console.log(response, "1");
            } else {
              return "Error" + xhr.status;
            }
          }
        };
      }
```

### 5.使用promise实现ajax

```js
// promise 封装实现：
function getJSON(url) {
  // 创建一个 promise 对象
  let promise = new Promise(function(resolve, reject) {
    let xhr = new XMLHttpRequest();
    // 新建一个 http 请求
    xhr.open("GET", url, true);
    // 设置状态的监听函数
    xhr.onreadystatechange = function() {
      if (this.readyState !== 4) return;
      // 当请求成功或失败时，改变 promise 的状态
      if (this.status === 200) {
        resolve(this.response);
      } else {
        reject(new Error(this.statusText));
      }
    };
    // 设置错误监听函数
    xhr.onerror = function() {
      reject(new Error(this.statusText));
    };
    // 设置响应的数据类型
    xhr.responseType = "json";
    // 设置请求头信息
    xhr.setRequestHeader("Accept", "application/json");
    // 发送 http 请求
    xhr.send(null);
  });
  return promise;
}
```



### 6.手写 apply  call  bind

#### apply实现

判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。

判断传入上下文对象是否存在，如果不存在，则设置为 window 。

将函数作为上下文对象的一个属性。

判断参数值是否传入

使用上下文对象来调用这个方法，并保存返回结果。

删除刚才新增的属性

返回结果



```js
Function.prototype.myApply=function (context,...args){
    if(typeof this !=="function"){
        return new Error('typeError')
    }
    context.fn=this
    if(args){
        result=context.fn(...args)
    }else{
        result=context.fn()
    }
    delete context.fn
    return result
}
let obj = {
        a: 10,
        b: 20,
      };
function sum(a, b) {
        this.b = 100;
        console.log(this.a, this.b);
        return a + b;
      }
sum.myApply(obj, 10, 20);
```

#### call实现

判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。

判断传入上下文对象是否存在，如果不存在，则设置为 window 。

处理传入的参数，截取第一个参数后的所有参数。

将函数作为上下文对象的一个属性。

使用上下文对象来调用这个方法，并保存返回结果。

删除刚才新增的属性。

返回结果。

```js
 Function.prototype.myCall = function (context) {
        context = context || window;
        if (typeof this !== "function") {
          throw new Error("typeError");
        }
        let result;
        context.fn = this;
        let args = [...arguments].slice(1);
        if (args) {
          result = context.fn(...args);
        } else {
          result = context.fn();
        }
        delete context.fn;
        return result;
      };
      var obj = {
        n: 15,
      };
      function sum(n, m) {
        console.log(this);
        return n + m;
      }

      console.log(sum.myCall(obj, 10, 20));
```

#### bind实现

```js
// bind 函数实现
Function.prototype.myBind = function(context) {
  // 判断调用对象是否为函数
  if (typeof this !== "function") {
    throw new TypeError("Error");
  }
  // 获取参数
  var args = [...arguments].slice(1),
     fn = this;
  return function Fn() {
    // 根据调用方式，传入不同绑定值
    return fn.apply(
      this instanceof Fn ? this : context,
      args.concat(...arguments)
    );
  };
};
var obj = {
        n: 15,
      };
function sum(n, m) {
        console.log(this);
        return n + m;
      }
var ans=sum.myBind(obj, 10, 20)
console.log(ans());
```



### 7.手写promise.all

```js
function myPromiseAll(arrayList) {
        return new Promise((resolve, reject) => {
          let resultArr = [],
            count = 0;
          let length = arrayList.length;
          for (let i = 0; i < length; i++) {
            Promise.resolve(arrayList[i]).then(
              (result) => {
                count++;
                resultArr[i] = result;
                if (count == length) {
                  resolve(resultArr);
                }
              },
              (err) => {
                return reject(err);
              }
            );
          }
        });
      }

function test(num, delay) {
        return new Promise((resolve, reject) => {
          setTimeout(() => {
            num == 4 ? reject(num) : resolve(num);
          }, delay);
        });
      }
      let p1 = test(1, 1000);
      let p2 = test(2, 2000);
      let p3 = test(3, 3000);
      let p4 = test(4, 4000);
      myPromiseAll([p1, p2, p3]).then((result) => {
        console.log(result);
      });
```



### 8.手写promise.race

```js
function PromiseRace(arrayList) {
        return new Promise((resolve) => {
          for (let i = 0; i < arrayList.length; i++) {
            Promise.resolve(arrayList[i]).then((result) => {
              resolve(result);
            });
          }
        });
      }
      function test(num, time) {
        return new Promise((resolve, reject) => {
          setTimeout(() => {
            num == 4 ? reject() : resolve(num);
          }, time);
        });
      }
      let p1 = test(1, 2000);
      let p2 = test(2, 1000);
      let p3 = test(3, 5000);
      PromiseRace([p3, p1, p2]).then((res) => {
        console.log(res);
      });
```



### 9.实现函数科里化

#### 1.固定参数

理解  arg数组是不断被扩展的 length指的是传入的test函数的参数长度

test实际上就是内部的 temp()

```js
 function curry(fn) {
        let length = fn.length;
        return function temp() {
          let arg = [...arguments];
          if (arg.length >= length) {
            return fn(...arg);
          } else {
            return function () {
              return temp(...arg, ...arguments);
            };
          }
        };
      }
      function add(a, b, c) {
        return a + b + c;
      }
      let test = curry(add);
      console.log(test(1)(2, 3));
```

#### 2.不固定参数

通过最后一个不传参来判断执行结束

```js
// 每次调用的传进来的参数做累计处理
function reduce (...args) {
    return args.reduce((a, b) => a + b)
}
function currying (fn) {
  // 存放每次调用的参数
  let args = []
  return function temp (...newArgs) {
    if (newArgs.length) {
      // 有参数就合并进去，然后返回自身
      args = [ ...args, ...newArgs ]
      return temp
    } else {
      // 没有参数了，也就是最后一个了，执行累计结果操作并返回结果
      let val = fn.apply(this, args)
      args = [] //保证再次调用时清空
      return val
    }
  }
}
let add = currying(reduce)
console.log(add(1)(2, 3, 4)(5))  //temp{ }
console.log(add(1)(2, 3, 4)(5)())  //15
console.log(add(1)(2, 3)(4, 5)())  //15
```



```js
function curry(fn) {
        let arg = [...arguments].slice(1);
        let temp = function temp() {
          arg = [...arg, ...arguments];
          return curry(fn, ...arg);
        };
        temp.toString = function () {
          return fn.apply(null, arg);
        };
        return temp;
      }

      function fn() {
        return [...arguments].reduce((pre, cur) => {
          return pre + cur;
        }, 0);
      }
      let test = curry(fn);
			console.log(test())
      console.log(test(1)(2, 3)(4)(5);  //temp
      console.log(test(1)(2, 3)(4)(5).toString());
```

#### 3.固定参数的add函数

```js
function add(x) {
      let sum = x;
      let temp = function (y) {
        sum += y;
        return temp;
      };
      temp.toString = function () {
        return sum;
      };
      return temp;
    }
    let a = add(1)(2)(4);
    console.log(a.toString());
```



#### 4.不固定参数的add函数

```js
 function add() {
        let arg = [...arguments];
        let add = function () {
          arg.push(...arguments);
          return add;
        };
        add.toString= function () {
          return arg.reduce((pre, cru) => {
            return pre + cru;
          });
        };
        return add;
      }
      console.log(add(1)(2)(3)(4)(5).toString());
```





### 10.实现new

1.  创建了一个全新的对象。
2.  新对象的`__proto__`属性指向构造函数的`prototype`属性。
3.  生成的新对象会绑定到函数调用的`this`。
4.  通过`new`创建的每个对象将最终被链接到这个函数的`prototype`对象上。
5.  如果函数没有返回对象类型`Object`(包含`Functoin`, `Array`, `Date`, `RegExg`, `Error`)，那么`new`表达式中的函数调用会自动返回这个新的对象

```javascript
function news(fn, ...arg) {
        let obj = {};
        obj.__proto__ = fn.prototype;
        fn.apply(obj, arg);
        return obj;
      }

      // 使用方法
      function Person(name, age) {
        this.name = name;
        this.age = age;
      }
      let person1 = news(Person, "张三", 15);
      console.log(person1);

      let person2 = new Person("李四", 15);
      console.log(person2);
```

ES6中 new.target 是指向构造函数  函数名.target 

```js
function ourNew(context) {	
    // 1.创建一个空对象
    var obj = new Object();
    // 2.取出构造函数,假设此构造函数有返回值
    var constructor = [].shift.call(arguments);
    // 3.继承构造函数的原型
    obj._proto_ = constructor.prototype; //Object.create
    // 4.为新建的对象调用构造函数，生成内部属性，同时构造函数运行时返回它想返回的值
    var Returned = constructor.apply(obj, arguments);
    // 5.返回对象
    return typeof Returned === 'object' ? Returned : person;
}
```



### 11.实现Instanceof

```js
function myInstanceof(left, right) {
        let proto = Object.getPrototypeOf(left),
          prototype = right.prototype;

        while (1) {
          if (!proto) return false;
          if (proto === prototype) return true;

          proto = Object.getPrototypeOf(proto);
        }
      }
      console.log(myInstanceof([1, 3, 4], Array));
      console.log(myInstanceof({}, Array));
      console.log(myInstanceof(new Date(), Object));
      console.log(myInstanceof(2, Array));
```



### 12.手写promise

#### 链式调用原理

我门常常用到 new Promise().then().then() ,这就是链式调用，用来解决回调地狱

1、为了达成链式，**我们默认在第一个then里返回一个promise**。规定了一种方法，就是**在then里面返回一个新的promise**,称为promise2： promise2 = new Promise((resolve, reject)=>{})
•将这个promise2返回的值传递到下一个then中
•如果返回一个普通的值，则将普通的值传递给下一个then中

2、当我们在第一个then中 return 了一个参数（参数未知，需判断）。这个return出来的新的promise就是onFulfilled()或onRejected()的值

**规定onFulfilled()或onRejected()的值，即第一个then返回的值，叫做x，判断x的函数叫做resolvePromise**

```js
then(onFulfilled,onRejected) {
    // 声明返回的promise2
    let promise2 = new Promise((resolve, reject)=>{
      if (this.state === 'fulfilled') {
        let x = onFulfilled(this.value);
        resolvePromise(promise2, x, resolve, reject);
      };
      if (this.state === 'rejected') {
        let x = onRejected(this.reason);
        resolvePromise(promise2, x, resolve, reject);
      };
      if (this.state === 'pending') {
        this.onResolvedCallbacks.push(()=>{
          let x = onFulfilled(this.value);
          resolvePromise(promise2, x, resolve, reject);
        })
        this.onRejectedCallbacks.push(()=>{
          let x = onRejected(this.value);
          resolvePromise(promise2, x, resolve, reject);
        })
      }
    });
    // 返回promise，完成链式
    return promise2;
  }
```

规定了一段代码，让不同的promise代码互相套用，叫做resolvePromise
•如果 x === promise2，则是会造成循环引用，自己等待自己完成，则报“循环引用”错误

```js
let p = new Promise(resolve => {
  resolve(0);
});
var p2 = p.then(data => {
  // 循环引用，自己等待自己完成，一辈子完不成
  return p2;
})

```

1、判断x

•x 不能是null
•x 是普通值 直接resolve(x)
• x 是对象或者函数（包括promise）， let then = x.then 2、当x是对象或者函数（默认promise）
•声明了then
•如果取then报错，则走reject()
•如果then是个函数，则用call执行then，第一个参数是this，后面是成功的回调和失败的回调
•如果成功的回调还是pormise，就递归继续解析 3、成功和失败只能调用一个 所以设定一个called来防止多次调用

```js
function resolvePromise(promise2, x, resolve, reject){
  // 循环引用报错
  if(x === promise2){
    // reject报错
    return reject(new TypeError('Chaining cycle detected for promise'));
  }
  // 防止多次调用
  let called;
  // x不是null 且x是对象或者函数
  if (x != null && (typeof x === 'object' || typeof x === 'function')) {
    try {
      // A+规定，声明then = x的then方法
      let then = x.then;
      // 如果then是函数，就默认是promise了
      if (typeof then === 'function') { 
        // 就让then执行 第一个参数是this   后面是成功的回调 和 失败的回调
        then.call(x, y => {
          // 成功和失败只能调用一个
          if (called) return;
          called = true;
          // resolve的结果依旧是promise 那就继续解析
          resolvePromise(promise2, y, resolve, reject);
        }, err => {
          // 成功和失败只能调用一个
          if (called) return;
          called = true;
          reject(err);// 失败了就失败了
        })
      } else {
        resolve(x); // 直接成功即可
      }
    } catch (e) {
      // 也属于失败
      if (called) return;
      called = true;
      // 取then出错了那就不要在继续执行了
      reject(e); 
    }
  } else {
    resolve(x);
  }
}

```



#### 不完全实现（没有完全实现链式调用）

```javascript
/*  Promise有三个状态,包括Pending,resolved,rejected */
      //状态定义
      const PENDING = "pending";
      const RESOLVED = "resolved";
      const REJECTED = "rejected";

      function MyPromise() {
        //保存初始化状态
        var self = this;
        //初始化状态
        this.state = PENDING;
        //用于保存resolve或者rejected传入的值
        this.value = null;
        //用于保存resolve的回调函数
        this.resolvedCallbacks = [];
        //用于保存reject的回调函数
        this.rejectedCallbacks = [];

        //状态转变为resolved方法
        function resolved(value) {
          if (value instanceof MyPromise) {
            return value.then(resolved, rejected);
          }

          //保证代码的执行顺序为本轮事件循环的末尾
          setTimeout(() => {
            //   只有状态pending才改变
            if (self.state === PENDING) {
              //改变状态
              self.status = RESOLVED;
              //设置传入的值
              self.value = value;
              //执行回调函数
              self.resolvedCallbacks.forEach((callback) => {
                callback(back);
              });
            }
          }, 0);
        }

        //状态转变为rejected方法
        function rejected(value) {
          //保证代码的执行顺序为本轮事件循环的末尾
          setTimeout(() => {
            //   只有状态pending才改变
            if (self.state === PENDING) {
              //改变状态
              self.status = REJECTED;
              //设置传入的值
              self.value = value;
              //执行回调函数
              self.rejectedCallbacks.forEach((callback) => {
                callback(back);
              });
            }
          }, 0);
        }

        //将两个方法传入函数执行
        try {
          fn(resolve, reject);
        } catch (e) {
          //遇到错误时,捕获错误,执行reject函数
          reject(e);
        }

        MyPromise.prototype.then = function (onResolved, onRejected) {
          //首先判断两个参数是否为函数类型,因为这两个参数是可选参数
          onResolved =
            typeof onResolved === "function"
              ? onResolved
              : function (value) {
                  return value;
                };
          onRejected =
            typeof onRejected === "function"
              ? onRejected
              : function (error) {
                  throw error;
                };

          //如果是等待状态,则将函数加入对应列表中
          if (this.status === PENDING) {
            this.resolvedCallbacks.push(onResolved);
            this.rejectedCallbacks.push(onRejected);
          }
          if (this.state === RESOLVED) {
            onResolved(this.value);
          }
          if (this.state === REJECTED) {
            onRejected(this.value);
          }
        };
      }
```

#### 完全规范实现

```js
class Promise{
  constructor(executor){
    this.state = 'pending';
    this.value = undefined;
    this.reason = undefined;
    this.onResolvedCallbacks = [];
    this.onRejectedCallbacks = [];
    let resolve = value => {
      if (this.state === 'pending') {
        this.state = 'fulfilled';
        this.value = value;
        this.onResolvedCallbacks.forEach(fn=>fn());
      }
    };
    let reject = reason => {
      if (this.state === 'pending') {
        this.state = 'rejected';
        this.reason = reason;
        this.onRejectedCallbacks.forEach(fn=>fn());
      }
    };
    try{
      executor(resolve, reject);
    } catch (err) {
      reject(err);
    }
  }
  then(onFulfilled,onRejected) {
    // onFulfilled如果不是函数，就忽略onFulfilled，直接返回value
    onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value => value;
    // onRejected如果不是函数，就忽略onRejected，直接扔出错误
    onRejected = typeof onRejected === 'function' ? onRejected : err => { throw err };
    let promise2 = new Promise((resolve, reject) => {
      if (this.state === 'fulfilled') {
        // 异步
        setTimeout(() => {
          try {
            let x = onFulfilled(this.value);
            resolvePromise(promise2, x, resolve, reject);
          } catch (e) {
            reject(e);
          }
        }, 0);
      };
      if (this.state === 'rejected') {
        // 异步
        setTimeout(() => {
          // 如果报错
          try {
            let x = onRejected(this.reason);
            resolvePromise(promise2, x, resolve, reject);
          } catch (e) {
            reject(e);
          }
        }, 0);
      };
      if (this.state === 'pending') {
        this.onResolvedCallbacks.push(() => {
          // 异步
          setTimeout(() => {
            try {
              let x = onFulfilled(this.value);
              resolvePromise(promise2, x, resolve, reject);
            } catch (e) {
              reject(e);
            }
          }, 0);
        });
        this.onRejectedCallbacks.push(() => {
          // 异步
          setTimeout(() => {
            try {
              let x = onRejected(this.reason);
              resolvePromise(promise2, x, resolve, reject);
            } catch (e) {
              reject(e);
            }
          }, 0)
        });
      };
    });
    // 返回promise，完成链式
    return promise2;
  }
}

```

#### 全部方法实现

```js
class Promise{
  constructor(executor){
    this.state = 'pending';
    this.value = undefined;
    this.reason = undefined;
    this.onResolvedCallbacks = [];
    this.onRejectedCallbacks = [];
    let resolve = value => {
      if (this.state === 'pending') {
        this.state = 'fulfilled';
        this.value = value;
        this.onResolvedCallbacks.forEach(fn=>fn());
      }
    };
    let reject = reason => {
      if (this.state === 'pending') {
        this.state = 'rejected';
        this.reason = reason;
        this.onRejectedCallbacks.forEach(fn=>fn());
      }
    };
    try{
      executor(resolve, reject);
    } catch (err) {
      reject(err);
    }
  }
  then(onFulfilled,onRejected) {
    onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value => value;
    onRejected = typeof onRejected === 'function' ? onRejected : err => { throw err };
    let promise2 = new Promise((resolve, reject) => {
      if (this.state === 'fulfilled') {
        setTimeout(() => {
          try {
            let x = onFulfilled(this.value);
            resolvePromise(promise2, x, resolve, reject);
          } catch (e) {
            reject(e);
          }
        }, 0);
      };
      if (this.state === 'rejected') {
        setTimeout(() => {
          try {
            let x = onRejected(this.reason);
            resolvePromise(promise2, x, resolve, reject);
          } catch (e) {
            reject(e);
          }
        }, 0);
      };
      if (this.state === 'pending') {
        this.onResolvedCallbacks.push(() => {
          setTimeout(() => {
            try {
              let x = onFulfilled(this.value);
              resolvePromise(promise2, x, resolve, reject);
            } catch (e) {
              reject(e);
            }
          }, 0);
        });
        this.onRejectedCallbacks.push(() => {
          setTimeout(() => {
            try {
              let x = onRejected(this.reason);
              resolvePromise(promise2, x, resolve, reject);
            } catch (e) {
              reject(e);
            }
          }, 0)
        });
      };
    });
    return promise2;
  }
  catch(fn){
    return this.then(null,fn);
  }
}
function resolvePromise(promise2, x, resolve, reject){
  if(x === promise2){
    return reject(new TypeError('Chaining cycle detected for promise'));
  }
  let called;
  if (x != null && (typeof x === 'object' || typeof x === 'function')) {
    try {
      let then = x.then;
      if (typeof then === 'function') { 
        then.call(x, y => {
          if(called)return;
          called = true;
          resolvePromise(promise2, y, resolve, reject);
        }, err => {
          if(called)return;
          called = true;
          reject(err);
        })
      } else {
        resolve(x);
      }
    } catch (e) {
      if(called)return;
      called = true;
      reject(e); 
    }
  } else {
    resolve(x);
  }
}
//resolve方法
Promise.resolve = function(val){
  return new Promise((resolve,reject)=>{
    resolve(val)
  });
}
//reject方法
Promise.reject = function(val){
  return new Promise((resolve,reject)=>{
    reject(val)
  });
}
//race方法 
Promise.race = function(promises){
  return new Promise((resolve,reject)=>{
    for(let i=0;i<promises.length;i++){
      promises[i].then(resolve,reject)
    };
  })
}
//all方法(获取所有的promise，都执行then，把结果放到数组，一起返回)
Promise.all = function(promises){
  let arr = [];
  let i = 0;
  function processData(index,data){
    arr[index] = data;
    i++;
    if(i == promises.length){
      resolve(arr);
    };
  };
  return new Promise((resolve,reject)=>{
    for(let i=0;i<promises.length;i++){
      promises[i].then(data=>{
        processData(i,data);
      },reject);
    };
  });
}

```



### 13.手写数组方法

#### 手写reduce

```js
Array.prototype.myReduce=function (cb,initialValue){
	const array=this;
	let pre=initialValue||array[0]
	const startIndex=initialValue?0:1
	for(let i=startIndex;i<array.length;i++){
		const cur=array[i]
		pre=cb(pre,cur,i,array)
	}
	return pre
}
```

#### 手写forEach

```js
    Array.prototype.myforEach = function (fn, thisValue) {
        let index = 0;
        let arr = thisValue || this;
        if (typeof fn !== 'function') {
            throw new TypeError(fn + 'is not a function')
        }
        while (index < arr.length) {
            if (index in arr) {
                fn.call (thisValue, arr[index], index, arr)
            }
            index ++
        }
    };
    
    let arr = [1, 3, 5, 7]
    arr.myforEach((item, i , arr) =>{
        console.log('item:' + item + 'i:' + i)
    })
```

#### 手写map

```js
    Array.prototype.mymap = function(fn,thisValue){
        let arr = thisValue || this
        let index = 0
        let newArr = [];
        if(typeof fn !== 'function'){
            throw new TypeError(fn + 'is not function')
        }
        while(index<arr.length){
            if(index in arr){
                let result = fn.call(thisValue, arr[index], index, arr)
                newArr[index] = result //返回一个新数组
            }
            index++
        }
        return newArr
    }
    
    let arr = [1,3,5,7]
    let newArr = arr.mymap((item)=>{
        return item*3
    })
    console.log(newArr)
```

#### 手写flat

```js
Array.prototype.myflat = function (num = 1) {
        if (!Number(num) || Number(num) < 0) {
            return this;
        }
        var arr = []
        this.forEach((item) => {
            if (Array.isArray(item)) {
                arr = arr.concat(item.flat(--num))
            } else {
                arr.push(item)
            }
        })
        return arr
    }
const arr = [1, [2, [3, 'a', [4]]]]

console.log(arr.myflat('dsdsadf'));  // [1, [2, [3, 'a', [4]]]]
console.log(arr.myflat(-32)); // [1, [2, [3, 'a', [4]]]]
console.log(arr.myflat(0));   // [1, [2, [3, 'a', [4]]]]
console.log(arr.myflat('1'));   // [1, 2, [3, 'a', [4]]]
console.log(arr.myflat('2'));    // [1, 2, 3, 'a', [4]]
console.log(arr.myflat(3));       // [1, 2, 3, 'a', 4]
console.log(arr.myflat(Infinity));     // [1, 2, 3, 'a', 4]
console.log(arr.myflat('Infinity'));   // [1, 2, 3, 'a', 4]
```



#### reduce 实现一个 map

```js
Array.prototype.mapByreduce=function(fn,context=null){
	let arr=this;
	if(typeof fn!=='function'){
		throw new TypeError('is not a function');
	}
	return arr.reduce((pre,cur,index,array)=>{
		let res=fn.call(context,cur,index,array);
			return [...pre,res]
	},[])
}
```



### 14.手写promisify

```js
function promisify(fn) {
    console.log(fn,"fn"); // 保存的是原始函数(add)
    return function (...args) {
        console.log(...args,"...args"); // 2 6 保存的是调用时的参数
        //返回promise对象
        return new Promise(function (resolve, reject) {
            // 将callback放到参数末尾,并执行callback函数
            args.push(function (err, ...arg) {
                console.log(...args,"12"); // 2 6 callback,
                if (err) {
                    reject(err);
                    return;
                }
                resolve(...arg);
            });

            fn.apply(null, args);
        });
    }
}

// 示例
let add = (a,b, callback) => {
    let result = a+b;
    if(typeof result === 'number') {
        callback(null,result)
    }else {
        callback("请输入正确数字")
    }
}

const addCall = promisify(add);
addCall(2,6).then((res) => {
    console.log(res);
})

```



手动实现一个promisify函数的意思是：我们把一个异步请求的函数，封装成一个可以具有 `then`方法的函数，并且在`then`方法中返回异步方法执行结果的这么一个函数

1. 具有 then 方法
2. then 方法里返回异步接口执行结果

```js
// 首先定一个需要进行 promisify 的函数
function asyncFn(a, b, callback) {
        // 异步操作，使用 setTimeout 模拟
        console.log('异步请求参数', a, b)
        setTimeout(function() {
                callback('异步请求结果')
        }, 3000)
}

// 我们希望调用的方式是
const proxy = promisify(asyncFn)
proxy(11,22).then(res => {
        // 此处输出异步函数执行结果
        console.log(res)
})

// 定义一个方法， 需要针对异步方法做封装，所以需要一个入参，既需要promisify的原异步方法
function promisify( asyncFn ) {
        // 方法内部我们需要调用asyncFn方法，并传递原始参数，所以需要返回一个方法来接收参数
        return function(...args) { // 由于需要接收参数，所以参数我们可以写为...args
                // 我们需要执行异步操作，并返回一个结果，所以返回一个 promise实例
                return new Promise(resolve => {
                        // asyncFn 需要执行一个回调，所以定义一个回调方法
                        const callback = function(...args) {
                              resolve(args)
                         }
                        args.push(callback)
                        asyncFn.apply(null, args)
                })
        }
}

```

```js
function promisify(fn) {
    return function (...args) {
        return new Promise(function (resolve, reject) {
            args.push(function (err, ...arg) {
                if (err) {
                    reject(err);
                    return;
                }
                resolve(...arg);
            });

            fn.apply(null, args);
        });
    }
}
```



### 15.用setTimeout实现setInterval

setTimeout() ：在指定的毫秒数后调用函数或计算表达式，只执行一次。setInterval() ：按照指定的周期（以毫秒计）来调用函数或计算表达式。方法会不停地调用函数，直到 clearInterval() 被调用或窗口被关闭。

使用递归函数，不断地去执行setTimeout从而达到setInterval的效果

setInterval 的作用是每隔一段指定时间执行一个函数，但是这个执行不是真的到了时间立即执行，它真正的作用是每隔一段时间将事件加入事件队列中去，只有当当前的执行栈为空的时候，才能去从事件队列中取出事件执行。所以可能会出现这样的情况，就是当前执行栈执行的时间很长，导致事件队列里边积累多个定时器加入的事件，当执行栈结束的时候，这些事件会依次执行，因此就不能到间隔一段时间执行的效果。

针对 setInterval 的这个缺点，我们可以使用 setTimeout 递归调用来模拟 setInterval，这样我们就确保了只有一个事件结束了，我们才会触发下一个定时器事件，这样解决了 setInterval 的问题。

实现思路是使用递归函数，不断地去执行 setTimeout 从而达到 setInterval 的效果

```js
function mySetInterval(fn, delay){
  function interval(){
    setTimeout(interval, delay);
    fn();
  }
  setTimeout(interval, delay)
}
```

限制调用次数

```js
function mySetInterval(fn, delay,count){
  function interval(){
    if(typeof count==='undefined'||count-->0){
      setTimeout(interval, delay);
      try{
        fn()
      }catch(e){
        count = 0;
        throw e.toString();
      }
    }
  }
  setTimeout(interval, delay)
}
```

### 16.promise串行执行

简单例子

```js
const p1 = () => {
	return new Promise((resolve) => {
		setTimeout(() => {
			console.log('p1');
			resolve();
                }, 2000)
            })
        }
const p2 = () => {
	return new Promise((resolve) => {
		setTimeout(() => {
			console.log('p2');
			resolve();
                }, 2000)
            })
        }

p1().then(() => {
    	return p2();
   }).then(() => {
   		console.log('end')
})

```



**利用`reduce`函数既能遍历数组，又能在前后元素之间建立联系的特点**

```js
const funcArr = [
    () =>
        new Promise((resolve) => {
            setTimeout(() => resolve(1), 2000);
        }),
    () =>
        new Promise((resolve) => {
            setTimeout(() => resolve(2), 1000);
        }),
    () =>
        new Promise((resolve) => {
            setTimeout(() => resolve(3), 3000);
        }),
];
/**
 * @description: 实现Promise的串行
 * @param {*}: 接收一个包含多个返回Promise对象的函数的数组
 * @return {*}: 返回一个Promise对象
 */
// 函数最终返回一个promise
function runPromiseByQueue(promiseFuncArr) {
  const res = [];
  return new Promise((resolve, reject) => {
    promiseFuncArr
      .reduce(    //数组每一项都返回了一个promise   data相当于res
        (acc, cur) => acc.then(cur).then((data) => res.push(data)),
        Promise.resolve()
      )
      // reduce函数最终返回一个promise，在onResolved这一步骤执行resolve，将结果输出
      .then(() => resolve(res));
  });
}

runPromiseByQueue(funcArr).then(data => console.log(data)) // 6s后输出[1,2,3]


```

```js
var urls = ['url1','url2','url3','url4'];
const getResponse = (url)=>{
	return new Promise((resolve,reject)=>{
		console.log('参数为：',url)
		setTimeout(()=>{
			console.log('异步请求后结果为','afeter'+url);
			resolve("success")
		},1000)
	})
}

function serial(tasks){
	var result = [];
	return tasks.reduce((accumulator,item,index)=>{
	    return accumulator.then(res=>{
		return getResponse(item).then(res=>{
		    result[index] = res
		    return index == tasks.length - 1 ? result : item
		})
	    })
	},Promise.resolve())
}
```

```js
// 实现 `chainPromise` 函数
// 请在不使用 `async` / `await` 语法的前提下完成
// 完成promise的串行执行

function getPromise(time) {
  return new Promise((resolve, reject) => {
    setTimeout(Math.random() > 0.5 ? resolve : reject, time, time);
  });
}

function chainPromise(arr) {
  let res = [];
  return new Promise((resolve, reject) => {
    arr
      .reduce((pre, cur) => {
        return getPromise(pre)
          .then((result) => {
            res.push(result);
            return getPromise(cur);
          })
          .catch((err) => {
            res.push(err);
            return getPromise(cur);
          });
      })
      .then((result) => {
        res.push(result);
      })
      .catch((err) => {
        res.push(err);
      })
      .finally(() => {
        resolve(res);
      });
  });
}

let time = [2000, 4000, 3000, 1000];
let res = chainPromise(time);
//等待10s后输出结果
res.then(console.log);

```



### 17.基于Promise的fetch

```js
const log = console.log;
function maxRequest(url = ``, times = 3) {
  // 1. 闭包，保存私有属性
  function autoRetry (url, times) {
    console.log('times = ', times);
    times--;
    // 2. fetch 本身返回值就是 Promise，不需要再次使用 Promise 包裹
    return fetch(url).then(value => {
        if(value.status === 200) {
          console.log(`OK`, value);
          // 3. 手动返回 Promise 的 value， 没有返回值 默认返回 undefined
          return value;
        } else {
          throw new Error(` http code error: ${value.status }`);
        }
      }).catch((err) => {
        console.log(`Error`, err);
        if (times < 1) {
          // 4. 方便后续的 thenable 处理 error
          throw new Error('over max request times!');
        } else {
          // 5. 返回递归方法 
          return autoRetry(url, times);
        }
      });
  }
  // 6. 返回一个 Promise 的结果 （成功 Promise 或失败 Promise）
  return autoRetry(url, times);
}

// error test case
maxRequest(`https://cdn.xgqfrms.xyz/json/badges.js`)
  .then(res => res.json())
  .then(json=> console.log('json =', json))
  .catch(err => console.error(`err =`, err))
  .finally(() => {
      console.log('whatever close loading...');
  });

// sucess test case
maxRequest(`https://cdn.xgqfrms.xyz/json/badges.json`)
  .then(res => res.json())
  .then(json=> console.log('json =', json))
  .catch(err => console.error(`err =`, err))
  .finally(() => {
      console.log(' whatever close loading...');
  });
```

### 18.Promise reject的时候自动retry

```js
function fetchWithAutoRetry(fetcher, maximumRetryCount) {
  return new Promise((resolve,reject)=> {
    let count = 0;
  const retry =  () => {
      fetcher().then((data) => {
        resolve(data);
      }).catch((error) => {
        if(count<maximumRetryCount) {
          count++;
          retry();
        } else {
          reject(error);
        }
      })
    }
     retry();
  });
}
```

### 19.实现async await

generator函数是不会自动执行的，每一次调用它的next方法，会停留在下一个yield的位置。

利用这个特性，我们只要编写一个自动执行的函数，就可以让这个generator函数完全实现async函数的功能

asyncToGenerator`接受一个`generator`函数，返回一个`promise

**下一次调用next的时候，传的参数会被作为上一个yield前面接受的值**

简单示例

```js
const getData = () => new Promise(resolve => setTimeout(() => resolve("data"), 1000))
function* testG() {
  // await被编译成了yield
  const data = yield getData()
  console.log('data: ', data);
  const data2 = yield getData()
  console.log('data2: ', data2);
  return 'success'
}

var gen = testG()

var dataPromise = gen.next()

dataPromise.then((value1) => {
    // data1的value被拿到了 继续调用next并且传递给data
    var data2Promise = gen.next(value1)
    
    // console.log('data: ', data);
    // 此时就会打印出data
    
    data2Promise.value.then((value2) => {
        // data2的value拿到了 继续调用next并且传递value2
         gen.next(value2)
         
        // console.log('data2: ', data2);
        // 此时就会打印出data2
    })
})

```

完整实现

```js
function asyncToGenerator(generatorFunc) {
  // 返回的是一个新的函数
  return function() {
  
    // 先调用generator函数 生成迭代器
    // 对应 var gen = testG()
    const gen = generatorFunc.apply(this, arguments)

    // 返回一个promise 因为外部是用.then的方式 或者await的方式去使用这个函数的返回值的
    // var test = asyncToGenerator(testG)
    // test().then(res => console.log(res))
    return new Promise((resolve, reject) => {
    
      // 内部定义一个step函数 用来一步一步的跨过yield的阻碍
      // key有next和throw两种取值，分别对应了gen的next和throw方法
      // arg参数则是用来把promise resolve出来的值交给下一个yield
      function step(key, arg) {
        let generatorResult
        
        // 这个方法需要包裹在try catch中
        // 如果报错了 就把promise给reject掉 外部通过.catch可以获取到错误
        try {
          generatorResult = gen[key](arg)
        } catch (error) {
          return reject(error)
        }

        // gen.next() 得到的结果是一个 { value, done } 的结构
        const { value, done } = generatorResult

        if (done) {
          // 如果已经完成了 就直接resolve这个promise
          // 这个done是在最后一次调用next后才会为true
          // 以本文的例子来说 此时的结果是 { done: true, value: 'success' }
          // 这个value也就是generator函数最后的返回值
          return resolve(value)
        } else {
          // 除了最后结束的时候外，每次调用gen.next()
          // 其实是返回 { value: Promise, done: false } 的结构，
          // 这里要注意的是Promise.resolve可以接受一个promise为参数
          // 并且这个promise参数被resolve的时候，这个then才会被调用
          return Promise.resolve(
            // 这个value对应的是yield后面的promise
            value
          ).then(
            // value这个promise被resove的时候，就会执行next
            // 并且只要done不是true的时候 就会递归的往下解开promise
            // 对应gen.next().value.then(value => {
            //    gen.next(value).value.then(value2 => {
            //       gen.next() 
            //
            //      // 此时done为true了 整个promise被resolve了 
            //      // 最外部的test().then(res => console.log(res))的then就开始执行了
            //    })
            // })
            function onResolve(val) {
              step("next", val)
            },
            // 如果promise被reject了 就再次进入step函数
            // 不同的是，这次的try catch中调用的是gen.throw(err)
            // 那么自然就被catch到 然后把promise给reject掉啦
            function onReject(err) {
              step("throw", err)
            },
          )
        }
      }
      step("next")
    })
  }
}

```




### 20.promise请求问题

请求五秒未完成则终止
提供两个模拟的 api
api = ()=> {};
warnning = ()=> {};
实现：

```js
function timing() {
    return new Promise((resolve,reject)=>{
        setTimeout(()=>{
            reject();
        },5000)
    })
}
function apiTiming() {
    const arr = [api(),timing()];
    Promise.race(arr).then(res=>{
        console.log(res);
    }).catch(e=>{
        warnning(e);
    })
}
```

### 21.限制promise并发请求

```js
function limitQueue(urls,limit){
  let i=0;
  //执行队列
  for(let i=0;i<limit;i++){
    run()
  }
  function run (){
    new Promise((resolve,reject)=>{
      const url=urls[i]
      i++;
      request(url).then(()=>{
        resolve()
      })
      .catch((e)=>{
        reject(e)
      })
    }).then(()=>{
      if(i<urls.length) run()
    })
  }
}
```



------

## 数据处理题

### 1.实现日期格式化函数

```js
dateFormat(new Date('2020-12-01'), 'yyyy/MM/dd') // 2020/12/01
dateFormat(new Date('2020-04-01'), 'yyyy/MM/dd') // 2020/04/01
dateFormat(new Date('2020-04-01'), 'yyyy年MM月dd日') // 2020年04月01日

const dateFormat = (dateInput, format)=>{
    var day = dateInput.getDate() 
    var month = dateInput.getMonth() + 1  
    var year = dateInput.getFullYear()   
    format = format.replace(/yyyy/, year)
    format = format.replace(/MM/,month)
    format = format.replace(/dd/,day)
    return format
}
```



### 2.数组扁平化

#### 简单版

**（1）递归实现**

普通的递归思路很容易理解，就是通过循环递归的方式，一项一项地去遍历，如果每一项还是一个数组，那么就继续往下遍历，利用递归程序的方法，来实现数组的每一项的连接：

```javascript
let arr = [1, [2, [3, 4, 5]]];
function flatten(arr) {
  let result = [];

  for(let i = 0; i < arr.length; i++) {
    if(Array.isArray(arr[i])) {
      result = result.concat(flatten(arr[i]));
    } else {
      result.push(arr[i]);
    }
  }
  return result;
}
flatten(arr);  //  [1, 2, 3, 4，5]
```

**（2）reduce 函数迭代**

从上面普通的递归函数中可以看出，其实就是对数组的每一项进行处理，那么其实也可以用reduce 来实现数组的拼接，从而简化第一种方法的代码，改造后的代码如下所示：

```javascript
let arr = [1, [2, [3, 4]]];
function flatten(arr) {
    return arr.reduce(function(acc, cur){
        return prev.concat(Array.isArray(cur) ? flatten(cur) : cur)
    }, [])
}
console.log(flatten(arr));//  [1, 2, 3, 4，5]
```

**（3）扩展运算符实现**

这个方法的实现，采用了扩展运算符和 some 的方法，两者共同使用，达到数组扁平化的目的：

```javascript
let arr = [1, [2, [3, 4]]];
function flatten(arr) {
    while (arr.some(item => Array.isArray(item))) {
        arr = [].concat(...arr);
    }
    return arr;
}
console.log(flatten(arr)); //  [1, 2, 3, 4，5]
```

**（4）split 和 toString**

可以通过 split 和 toString 两个方法来共同实现数组扁平化，由于数组会默认带一个 toString 的方法，所以可以把数组直接转换成逗号分隔的字符串，然后再用 split 方法把字符串重新转换为数组，如下面的代码所示：

```javascript
let arr = [1, [2, [3, 4]]];
function flatten(arr) {
    return arr.toString().split(',');
}
console.log(flatten(arr)); //  [1, 2, 3, 4，5]
```

通过这两个方法可以将多维数组直接转换成逗号连接的字符串，然后再重新分隔成数组。

**（5）ES6 中的 flat**

我们还可以直接调用 ES6 中的 flat 方法来实现数组扁平化。flat 方法的语法：`arr.flat([depth])`

其中 depth 是 flat 的参数，depth 是可以传递数组的展开深度（默认不填、数值是 1），即展开一层数组。如果层数不确定，参数可以传进 Infinity，代表不论多少层都要展开：

```javascript
let arr = [1, [2, [3, 4]]];
function flatten(arr) {
  return arr.flat(Infinity);
}
console.log(flatten(arr)); //  [1, 2, 3, 4，5]
```

可以看出，一个嵌套了两层的数组，通过将 flat 方法的参数设置为 Infinity，达到了我们预期的效果。其实同样也可以设置成 2，也能实现这样的效果。在编程过程中，如果数组的嵌套层数不确定，最好直接使用 Infinity，可以达到扁平化。

 **（6）正则和 JSON 方法** 在第4种方法中已经使用 toString 方法，其中仍然采用了将 JSON.stringify 的方法先转换为字符串，然后通过正则表达式过滤掉字符串中的数组的方括号，最后再利用 JSON.parse 把它转换成数组：

```javascript
let arr = [1, [2, [3, [4, 5]]], 6];
function flatten(arr) {
  let str = JSON.stringify(arr);
  str = str.replace(/(\[|\])/g, '');
  str = '[' + str + ']';
  return JSON.parse(str); 
}
console.log(flatten(arr)); //  [1, 2, 3, 4，5]
```

#### 限制层数

```js
function flat(arr,num=1){
  return num>0?
    arr.reduce(acc,cur)=>acc.concat(Array.isArray(cur))?flat(cur,num-1):cur),[])
   :arr.slice();
}
```

```js
function flatten(arr,level){
		function walk(arr,currLevel){
			let res=[];
			for(let item of arr){
				if(Array.isArray(item)&&currLevel<level){
					res=res.concat(walk(item,currLevel+1))
				}else{
					res.push(item)
				}
			}
			return res
		}
		return walk(arr,1)
}
```



### 3.数组去重

给定某无序数组，要求去除数组中的重复数字并且返回新的无重复数组。

ES6方法（使用数据结构集合）：

```javascript
const array = [1, 2, 3, 5, 1, 5, 9, 1, 2, 8];

Array.from(new Set(array)); // [1, 2, 3, 5, 9, 8]
```

ES5方法：使用map存储不重复的数字

```javascript
const array = [1, 2, 3, 5, 1, 5, 9, 1, 2, 8];

uniqueArray(array); // [1, 2, 3, 5, 9, 8]

function uniqueArray(array) {
  let map = {};
  let res = [];
  for(var i = 0; i < array.length; i++) {
    if(!map.hasOwnProperty([array[i]])) {
      map[array[i]] = 1;
      res.push(array[i]);
    }
  }
  return res;
}
```

### 4.大数运算

#### 大数相加

```js
function add(a,b){
	var a=a.split("");
	var b=b.split("");
	let sum=[],carry=0;
	while(a.length||b.length||carry){  //carry可以判断最后计算是否需要进位
		let aa =parseInt(a.pop())||0;
		let bb=parseInt(b.pop())||0;
		let s=aa+bb+carry;
		carry=Math.floor(s/10);
		sum.unshift(s%10);
	}
	sum=sum.join("");
	return sum;
}
console.log(add("163","956"));
```



```js
function add(a,b){
   let a=a.split(''),b=b.split('');
   let sum=[],flag=0;
    while(a.length||b.length){
          let num1=parseInt(a.pop())||0;
          let num2=parseInt(b.pop())||0;
        let temp=num1+num2+flag;
        if(temp>9){
            flag=1
            temp=temp%10
        }else{
            flag=0
        }
        sum.unshift(temp)
  }
  if(flag)sum.unshift(1)  //最后一次运算是否需要进位
    return sum.join('')
}
```

#### 大数相乘

以`multiply('11', '99')`为例，思路如下：

1.  初始化一个数组`res`用来存放计算结果

2.  双重for循环，从后往前，遍历str1和str2，将

    ```
    str1[i]*str2[j]+res[i+j]
    ```

    的结果存储到res中。

    -   一次循环后，res = [empty, 9,9]
    -   二次循环后，res = [9, 18,9]

3.  从后往前遍历res

    -   `res[index - 1] += parseInt(res[index] / 10)`，res当前项取整和res前一项相加（完成>10进一的操作）
    -   `res[index] %= 10`，res当前项取余
    
    
    
    实验111*222
    
    打印res数组得到
    
    [ 2, 4, 6, 4, 2 ]

```js

function multiply(str1, str2) {
  if (str1 == '0' || str2 == '0') return '0'
  let res = [],
    i = str1.length - 1,
    j = str2.length - 1;
  for (; i >= 0; i--) {
    let n1 = str1[i] - '0'
    j = str2.length - 1
    for (; j >= 0; j--) {
      let n2 = str2[j] - '0'
      res[i + j] = res[i + j] || 0
      res[i + j] += n1 * n2
    }
  }
  let index = res.length - 1
  while (index >= 1) {
    res[index - 1] += parseInt(res[index] / 10)
    res[index] %= 10
    index--
  }
  return res.join('')
}
var num1 = '546212878237823';
var num2 = '42362078923598';
console.log(multiply(num1, num2))
```



### 5.数字千分位逗号隔开

简单写法

```js
let number =123456789
function formatNum(number){
  let str=''
  let arr=number.toString().split('')
  let length=arr.length
  while(length>3){
  str=`,${arr.splice(-3).join('')}`+str
  length=arr.length
  }
  return arr.join('')+str
}
console.log(formatNum(number))
```

考虑小数

```js
function formatNum(number) {
    var arr = (number + '').split('.');
    var int = arr[0].split('');
    var fraction = arr[1] || '';
    var r = "";
    var len = int.length;
    int.reverse().forEach(function (v, i) {
        if (i !== 0 && i % 3 === 0) {
            r = v + "," + r;
        } else {
            r = v + r;
        }
    })
    return r + (!!fraction ? "." + fraction : '');
}
//!!相当于将转换成布尔类型
```



考虑负数

```js
function formatNum(num) {
    let numPrefix = ''
    let numArr = ''
    let numDist = ''

    // 处理负数情况
    if (num < 0) {
      numPrefix = '-'
      numArr = String(num).slice(1).split('').reverse()
    } else {
      numArr = String(num).split('').reverse()
    }

    for (let i = 0; i < numArr.length; i++) {
      numDist += numArr[i]
      if ((i + 1) % 3 === 0 && (i + 1) < numArr.length) {
        numDist += ','
      }
    }

    return numPrefix + numDist.split('').reverse().join('')
  }
```

正则

```js
    let num = '12345678'
    let reg = /(?=\B(\d{3})+$)/g
    console.log(num.replace(reg,",")) //12,345,678
```



### 6.解析URL Params为对象

```js
let url = 'http://www.domain.com/?user=anonymous&id=123&id=456&city=%E5%8C%97%E4%BA%AC&enabled';
parseParam(url)
/* 结果
{ user: 'anonymous',
  id: [ 123, 456 ], // 重复出现的 key 要组装成数组，能被转成数字的就转成数字类型
  city: '北京', // 中文需解码
  enabled: true, // 未指定值得 key 约定为 true
}
*/
function parseParam(url) {
  const paramsStr = /.+\?(.+)$/.exec(url)[1]; // 将 ? 后面的字符串取出来
  const paramsArr = paramsStr.split('&'); // 将字符串以 & 分割后存到数组中
  let paramsObj = {};
  // 将 params 存到对象中
  paramsArr.forEach(param => {
    if (/=/.test(param)) { // 处理有 value 的参数
      let [key, val] = param.split('='); // 分割 key 和 value
      val = decodeURIComponent(val); // 解码
      val = /^\d+$/.test(val) ? parseFloat(val) : val; // 判断是否转为数字
      if (paramsObj.hasOwnProperty(key)) { // 如果对象有 key，则添加一个值
        paramsObj[key] = [].concat(paramsObj[key], val);
      } else { // 如果对象没有这个 key，创建 key 并设置值
        paramsObj[key] = val;
      }
    } else { // 处理没有 value 的参数
      paramsObj[param] = true;
    }
  })
  return paramsObj;
}

```



### 7.字符串和驼峰式转换

#### 字符串转驼峰

##### 数组法

```js
//空格式
let a='hello world'
var b=a.split(' ').map(item=>{
    return item[0].toUpperCase()+item.substr(1,item.length)
}).join('')
console.log(b)

//横线式
let str='hello-world'
function getCamelCase(str) {
    let arr = str.split('-');
    return arr.map((item, index) => {
        if (index === 0) {
            return item;
        } else {
           return item.chartAt(0).toUpperCase() + item.slice(1); 
        }
    }).join('');
}
console.log(getCamelCase(str))
```

##### 正则法

```js
let a='hello world'
let b = a.replace((/\s\w/g),function(v){
	return v.substring(1).toUpperCase()
})
console.log(b)

let a='hello-world'
let b = a.replace((/-\w/g),function(v){
	return v.substring(1).toUpperCase()
})
console.log(b)
```

#### 驼峰转字符串

##### 数组法

```js
//横线式
const str = 'helloWorld';
function getKebabCase(str) {
    let arr = str.split('');
    let result = arr.map((item) => {
        if (item.toUpperCase() === item) {
            return '-' + item.toLowerCase();
        } else {
            return item;
        }
    }).join('');
    return result;
}
console.log(getKebabCase(str));
```

```js
const str = 'helloWorld';
function getKebabCase(prev, cur, index, array) {
    if (/[A-Z]/.test(cur)) {
        cur = cur.toLowerCase();
        if (index === 0) {
            return prev + cur;
        } else {
            return prev + '-' + cur;
        }
    } else {
        return prev + cur;
    }
}

function toKebabCase(arr) {
    if (typeof arr === 'string') {
        arr = arr.split('');
    }
    return arr.reduce(getKebabCase, '');
}

let test1 = toKebabCase(str); 
let test2 = [].reduce.call(st, getKebabCase, '');  
```



##### 正则法

```js
const str = 'helloWorld';
function getKebabCase(str) {
    let temp = str.replace(/[A-Z]/g, function(i) {
        return '-' + i.toLowerCase();
    })
    if (temp.slice(0,1) === '-') {
        temp = temp.slice(1);   //如果首字母是大写，执行replace时会多一个-，需要去掉
    }
    return temp;
}
console.log(getKebabCase(str));
```



### 8.Js对象转树形结构

```js
// 转换前：
source = [{
            id: 1,
            pid: 0,
            name: 'body'
          }, {
            id: 2,
            pid: 1,
            name: 'title'
          }, {
            id: 3,
            pid: 2,
            name: 'div'
          }]
// 转换为: 
tree = [{
          id: 1,
          pid: 0,
          name: 'body',
          children: [{
            id: 2,
            pid: 1,
            name: 'title',
            children: [{
              id: 3,
              pid: 2,
              name: 'div'
            }]
          }]
        }]

```

```js
source = [{
            id: 1,
            pid: 0,
            name: 'body'
          }, {
            id: 2,
            pid: 1,
            name: 'title'
          }, {
            id: 3,
            pid: 2,
            name: 'div'
          }]
//
function treeing (arr) {
  let tree = []
  const map = {}
  for (let item of arr) {
    // 一个新的带children的结构
    let newItem = map[item.id] = {
      ...item,
      children: []
    }
    if (map[item.pid]) { // 父节点已存进map则在父节点的children添加新元素
      let parent = map[item.pid]
      parent.children.push(newItem)
    } else { // 没有父节点，在根节点添加父节点
      tree.push(newItem)
    }
  }
  return tree
}
//
function toTree(data) {
                let result = []
                if(!Array.isArray(data)) {
                    return result
                }
                data.forEach(item => {
                    delete item.children;
                });
                let map = {};
                data.forEach(item => {
                    map[item.id] = item;
                });
                data.forEach(item => {
                    let parent = map[item.pid];
                    if(parent) {
                        (parent.children || (parent.children = [])).push(item);
                    } else {
                        result.push(item);
                    }
                });
                return result;
            }

console.log(treeing(source))
```

### 9.字符串去重和反转

字符串去重

```js
let str = '11223344aabbcc'
function strSeparate(s) {
    return [...new Set([...s])].join('');
    // or return [...new Set(s.split(''))].join('')
}
console.log(strSeparate(str))

let str = '11223344aabbcc'
function strSeparate(s) {
    // 使用展开运算符，字符串转换成数组
    s = [...str];
    let arr = [];
    for(let i = 0; i < s.length; i++) {
        if(arr.indexOf(s[i]) == -1) {
            arr.push(s[i])
        }
    }
    return arr.join('');
}
console.log(strSeparate(str))
```



### 10.数字反转

```js
var reverse = function(x) {
    let res = 0;
    while(x){
        res = res * 10 + x % 10;
        if(res > Math.pow(2, 31) - 1 || res < Math.pow(-2, 31)) return 0;
        x = ~~(x / 10);
    }
    return res;
};

```

```js
var reverse = function (x) {
    let y = parseInt(x.toString().split("").reverse().join(""));
    if (x < 0)
        y = - y;
    return y > 2147483647 || y < -2147483648 ? 0 : y;
};

```



### 11.计算目录树的深度

得出depth即为树的高度得出depth即为树

定义变量depth为0

定义一个空数组temp,然后遍历tree，如果tree有children，就push到temp里面

开始while循环，如果temp长度不为0，depth++；如果temp长度为0，停止

得出depth即为树的高度

得出depth即为树的高度得出depth即为树的高度得出depth即为树的高度

```js
const tree = {
  name: 'root',
  children: [
    { name: '叶子1-1' },
    { name: '叶子1-2' },
    {
      name: '叶子2-1',
      children: [{
        name: '叶子3-1',
        children: [{
          name: '叶子4-1'
        }]
      }]
    }
  ]
}
 
function getDepth(tree) {
  let depth = 0
 
  if (tree) {
    let arr = [tree]
    let temp = arr
    while (temp.length) {
      arr = temp
      temp = []
      for (let i = 0; i < arr.length; i++) {
        if (arr[i].children && arr[i].children.length) {
          for (let j = 0; j < arr[i].children.length; j++) {
            temp.push(arr[i].children[j])
          }
        }
      }
      depth++
    }
  }
  return depth
}console.log(getDepth(tree)); //输出4
```

### 12.树形结构获取路径名

```js
const treeData = [
  {
    name: "root",
    children: [
      { name: "src", children: [{ name: "index.html" }] },
      { name: "public", children: [] },
    ],
  },
];

const RecursiveTree = (data) => {
  data.map((item) => {
    console.log(item.name);
    if (item.children) {
      RecursiveTree(item.children);
    }
  });
};

RecursiveTree(treeData);
```

### 13.数组转化成树形结构

递归形式

```js
  const arr = [
  {id:"01", name: "张大大", pid:"", job: "项目经理"},
  {id:"02", name: "小亮", pid:"01", job: "产品leader"},
  {id:"03", name: "小美", pid:"01", job: "UIleader"},
  {id:"04", name: "老马", pid:"01", job: "技术leader"},
  {id:"05", name: "老王", pid:"01", job: "测试leader"},
  {id:"06", name: "老李", pid:"01", job: "运维leader"},
  {id:"07", name: "小丽", pid:"02", job: "产品经理"},
  {id:"08", name: "大光", pid:"02", job: "产品经理"},
  {id:"09", name: "小高", pid:"03", job: "UI设计师"},
  {id:"10", name: "小刘", pid:"04", job: "前端工程师"},
  {id:"11", name: "小华", pid:"04", job: "后端工程师"},
  {id:"12", name: "小李", pid:"04", job: "后端工程师"},
  {id:"13", name: "小赵", pid:"05", job: "测试工程师"},
  {id:"14", name: "小强", pid:"05", job: "测试工程师"},
  {id:"15", name: "小涛", pid:"06", job: "运维工程师"}
]
function toTree(list,parId){
	let len = list.length
	function loop(parId){
		let res = [];
		for(let i = 0; i < len; i++){
			let item = list[i]
			if(item.pid === parId){
				item.children = loop(item.id)
				res.push(item)
			}
		}
		return res
	}
	return loop(parId)
}

let result = toTree(arr,'')
console.log(result);

```

非递归形式

```js
  const arr = [
    { 'id': '29', 'pid': '', 'name': '总裁办' },
    { 'id': '2c', 'pid': '', 'name': '财务部' },
    { 'id': '2d', 'pid': '2c', 'name': '财务核算部' },
    { 'id': '2f', 'pid': '2c', 'name': '薪资管理部' },
    { 'id': 'd2', 'pid': '', 'name': '技术部' },
    { 'id': 'd3', 'pid': 'd2', 'name': 'Java研发部' }
  ]

  function tranListToTreeData(list) {
    // 1. 定义两个中间变量
    const treeList = [],  // 最终要产出的树状数据的数组
      map = {}        // 存储映射关系


    // 2. 建立一个映射关系，并给每个元素补充children属性.
    // 映射关系: 目的是让我们能通过id快速找到对应的元素
    // 补充children：让后边的计算更方便
    list.forEach(item => {
      if (!item.children) {
        item.children = []
      }
      map[item.id] = item
    })
    //  {
    //    "29": { 'id': '29', 'pid': '',     'name': '总裁办', children:[] },
    //    '2c': { 'id': '2c', 'pid': '',     'name': '财务部', children:[] },
    //    '2d': { 'id': '2d', 'pid': '2c', 'name': '财务核算部', children:[]},
    //    '2f': { 'id': '2f', 'pid': '2c', 'name': '薪资管理部', children:[]},
    //    'd2': { 'id': 'd2', 'pid': '',     'name': '技术部', children:[]},
    //    'd3': { 'id': 'd3', 'pid': 'd2', 'name': 'Java研发部', children:[]}
    //  }

    // 3. 循环
    list.forEach(item => {
      // 对于每一个元素来说，先找它的上级
      //    如果能找到，说明它有上级，则要把它添加到上级的children中去
      //    如果找不到，说明它没有上级，直接添加到 tree3List
      const parent = map[item.pid]
      if (parent) {
        parent.children.push(item)
      } else {
        treeList.push(item)
      }
    })
    // 4. 返回出去
    return treeList
  }

  const treeList = tranListToTreeData(arr)
  console.log(treeList);
```



### 14.对象扁平化

#### 1.带数组的

输入

```js
{
    a: 'a',
    b: [1, { c: true }, [3]],
    d: { e: undefined, f: 3 },
    g: null,
}
```

输出

```js
{
    a: "a",
    b[0]: 1,
    b[1].c: true,
    b[2][0]: 3,
    d.f: 3
    // null和undefined直接舍去
}
```



```js
var myObj={
	a: 'a',
		b: [1, { c: true }, [3]],
			d: { e: undefined, f: 3 },
	g: null,
}

function treeToObj(myObj) {
	function getObj(myObj, str, toObj) {
		const level = Object.keys(myObj)
		let levelStr = str.slice()
		if (levelStr != '') {
			levelStr = levelStr + '.'
		}
		for (key of level) {
			if (myObj[key]) {
				if (typeof (myObj[key]) === 'object') {
					getObj(myObj[key], levelStr + key, toObj)
				} else {
					toObj[levelStr + key] = myObj[key]
				}
			}
		}
		return toObj
	}
	return getObj(myObj,'',{})
}

console.log(treeToObj(myObj))
```

```js
var myObj = {
	a: 'a',
	b: [1, { c: true }, [3]],
	d: { e: undefined, f: 3 },
	g: null,
}

function treeToObj(myObj) {
	const res = {}
	function toObj(obj, str = null) {
		for (let key in obj) {
			if (typeof obj[key] === "number" || typeof obj[key] === "string" || typeof obj[key] === "boolean") {
				if (str === null) {
					res[key] = obj[key]
				} else if (Array.isArray(obj)) {
					res[str + '[' + key + ']'] = obj[key]
				} else {
					res[str + '.' + key] = obj[key]
				}
			} else if (Array.isArray(obj[key])) {
				if (str === null) {
					toObj(obj[key], key)
				} else if (Array.isArray(obj)) {
					toObj(obj[key], str + '[' + key + ']')
				} else {
					toObj(obj[key], str + '.' + key)
				}
			} else if (typeof obj[key] === 'object') {
				if (str === null) {
					toObj(obj[key], key)
				} else if (Array.isArray(obj)) {
					toObj(obj[key], str + '[' + key + ']')
				} else {
					toObj(obj[key], str + '.' + key)
				}
			}
		}
		return res;
	}
	return  toObj(myObj,'')
}
console.log(treeToObj(myObj))
```

#### 2.纯对象

```js
var entry = {
  a: {
    b: {
      c: {
        dd: 'abcdd'
      }
    },
    d: {
      xx: 'adxx'
    },
    e: 'ae'
  }
}

// 要求转换成如下对象
var output = {
  'a.b.c.dd': 'abcdd',
  'a.d.xx': 'adxx',
  'a.e': 'ae'
}
```



```js
var entry = {
  a: {
    b: {
      c: {
        dd: 'abcdd'
      }
    },
    d: {
      xx: 'adxx'
    },
    e: 'ae'
  }
}
function flatObj(obj,parentKey="",result={}){
	for(const key in obj){
		if(obj.hasOwnProperty(key)){
			let keyName=`${parentKey}${key}`
			if(typeof obj[key]==='object'){
				flatObj(obj[key],keyName+".",result)
			}else{
				result[keyName]=obj[key]
			}
		}
	}
	return result
}
console.log(flatObj(entry))
```



### 15.根据表达式计算字母数量

**描述**：输入一串字符串，根据字符串求出每个字母的数量并返回结果对象。（数字为1时可省略）
**示例一**：输入：A3B2，输出：{"A": 3, "B": 2}
**示例二**：输入：A(A(A2B)2)3C2，输出：{"A": 16, "B": 6, "C": 2}

```js

var countOfAtoms = function(formula) {
    //记录各个原子的值
    let dict = {}
    //栈中初始数字。用于表示单个原子的数字情况
    let stack = [1]
    //原子名
    let str = ''
    //暂且记录的原子数字情况，压入栈或者消耗后要重置。
    let count = 1;
    //从后往前遍历。
    for(let i = formula.length - 1; i >= 0; i-- ){
        const value = formula[i];
        //如果是数字。则记录
        if(!isNaN(value)){
            if(count === 1){
                count = value
            }else{
                count = parseInt(value + count)
            }
        };
        //如果是小写字母，则记录
        if(value >= 'a' && value <= 'z'){
            str = str + value;
        }
        //如果是右括号，则将记录的数字和栈顶部数字相乘并输出
        if(value === ')'){
            stack.push(stack[stack.length - 1] * count);
            count = 1;
        }
        //如果是左括号，则出栈
        if(value === '('){
            stack.pop();
        }
        //如果是大写字母，则将栈顶的值赋值给该原子。如果字典里有这个原子，则累加。重置临时记录的数字和原子值
        if(value >= 'A' && value <= 'Z'){
            let atomsValue = count * stack[stack.length-1];
           
            str = value + str;
            if(dict[str] === undefined){
                dict[str] = atomsValue;
            }else{
                dict[str] = dict[str] + atomsValue
            }
            count = 1;
            str = '';
        }
    }
    //按照字典排序
    let newkey = Object.keys(dict).sort();
    var result = {};//创建一个新的对象，用于存放排好序的键值对
    for (var i = 0; i < newkey.length; i++) {//遍历newkey数组
        result[newkey[i]] = dict[newkey[i]];//向新创建的对象中按照排好的顺序依次增加键值对
    }
    //按照要求的格式输出。
    let resultString = ''
    for(var key in result){
        resultString = resultString + key;
        if(result[key] > 1){
            resultString = resultString + result[key];
        }
    }
    return resultString
};
```

类似于[726. 原子的数量](https://leetcode-cn.com/problems/number-of-atoms/)

### 16.对象树遍历

```js
const tree = {
	name: 'root',
	children: [
		{
			name: 'c1',
			children: [
				{
						name: 'c11',
					children: []		
					},
					{
						name: 'c12',
					children: []		
				}
			]
		},
		{
			name: 'c2',
			children: [
				{
						name: 'c21',
					children: []		
					},
					{
						name: 'c22',
					children: []		
				}
			]
		}
	]
}

// 深度优先的方式遍历 打印 name
// ['root', 'c1','c11', 'c12', 'c2', 'c21', 'c22']

```

```js
function solve(root) {
            let stack = [],
                result = [];
            if(!root) return [];
            stack.push(root)
            while(stack.length) {
                let node = stack.pop()
                if(node == null ) continue
                result.push(node.name)
                for(let i = node.children.length-1; i >= 0; i--) {
                    // 这里就是面试的重点,应该从后面的节点压入栈中
                    stack.push(node.children[i])
                }
            }
            return result
        }

```

### 17.查找json中的children路径

现有如下json（简化为对象），已知每个节点id唯一，编写findNode(id)，返回路径，如findNode(5) 输出 1->4->5

```js
{
  id: 1,
  children: [
    { id: 2, children: [{ id: 3, children: [] }] },
    {
      id: 4,
      children: [
        { id: 5, children: [] },
        { id: 6, children: [] },
      ],
    },
    { id: 7, children: [] },
  ],
};
```

```js
function dfs(obj,path,target){
  if(obj.id==target){
    console.log(path.slice())
    return
  }
  for(let son of  obj.children){
    if(son!==[]){
      path.push(son.id)
      dfs(son,path,target)
      
    }
  }
}
```



### 18.手写JSON.stringify和JSON.parse

1.JSON.stringify
JSON.stringify() 方法将一个 JavaScript 对象或值转换为 JSON 字符串，如果指定了一个 replacer 函数，则可以选择性地替换值，或者指定的 replacer 是数组，则可选择性地仅包含数组指定的属性。

JSON.stringify(value[, replacer [, space]])

Boolean | Number| String 类型会自动转换成对应的原始值。
undefined、任意函数以及symbol，会被忽略（出现在非数组对象的属性值中时），或者被转换成 null（出现在数组中时）。
不可枚举的属性会被忽略。
如果一个对象的属性值通过某种间接的方式指回该对象本身，即循环引用，属性也会被忽略。
2.JSON.parse
JSON.parse() 方法用来解析JSON字符串，构造由字符串描述的JavaScript值或对象。提供可选的 reviver 函数用以在返回之前对所得到的对象执行变换(操作)。

JSON.parse(text[, reviver])

用来解析JSON字符串，构造由字符串描述的JavaScript值或对象。提供可选的reviver函数用以在返回之前对所得到的对象执行变换(操作)。

#### JSON.stringify

```js
function jsonStringify (obj) {
  let type = typeof obj;
  if (type !== "object" || type === null) {
    if (/string|undefined|function/.test(type)) {
      obj = '"' + obj + '"';
    }
    return String(obj);
  } else {
    let json = []
    arr = (obj && obj.constructor === Array);
    for (let k in obj) {
      let v = obj[k];
      let type = typeof v;
      if (/string|undefined|function/.test(type)) {
        v = '"' + v + '"';
      } else if (type === "object") {
        v = jsonStringify(v);
      }
      json.push((arr ? "" : '"' + k + '":') + String(v));
    }
    return (arr ? "[" : "{") + String(json) + (arr ? "]" : "}")
  }
}
jsonStringify({ x: 5 })
// "{"x":5}"
jsonStringify([1, "false", false])
// "[1,"false",false]"
jsonStringify({ b: undefined })
// "{"b":"undefined"}"
```

### 19.模板语法解析

```js
let obj = {
 name: 'Wow',
 age: 20
}
let str = "My name is ${name},I am ${age} ,I take 1000$ to buy a computer and write code function(){console.log('Hello World')}"

function templateString(str, obj) {
 let newStr = ''
 let flag = false
 let temp = ''
 for (let i = 0; i < str.length; i++) {
  let ch = str[i]
  if (ch === '$' && str[i + 1] === '{') {
   flag = true
   i++
   continue
  }
  if (flag) {
   if (ch === '}') {
    newStr = newStr + obj[temp]
    temp = ''
    flag = false
   } else {
    temp = temp + ch
   }
  } else {
   newStr = newStr + ch
  }
 }
 return newStr
}

console.log(templateString(str,obj))
```

### 20.判断对象相等  isEqual

编程题       

 写一个函数 判断类型   

function({} , {}) true      

function(1 , 1) true       

function('s' , 's') true      

function([] , []) true       

function(function () , function ()) false     

​      

```js
const compare = (a , b) =>{
   // 先判断全等的情况
   if(a === b){return true};
   // 考虑函数类型
   if(typeof a === typeof b === 'function'){
       return false;
   }
   // 基本类型
   if(typeof a !== typeof b){
       return false
   }
   // 数组 类型时
   if(a instanceof Array && b instanceof Array){
       if(a.length !== b.length){
           return false
       }
       if(a.join('') === b.join('')){
           return true
       }else{
           return false
       }
   }
   // 对象类型
   if(a instanceof Object && b instanceof Object){
       const c1 = Object.keys(a);
       const c2 = Object.keys(b);
       if(c1.length !== c2.length){
           return false
       }
       // 长度一致时
       for(let i in a){
           if(a[i] !== b[i]){
               return false
           }
           if(compare(a[i] , b[i]) === false){
               return false
           }
       }
       return true
   }
```

```js
const obj1  = {a:100,b:{x:10,y:20}}
const obj2  = {a:100,b:{x:10,y:20}}
isEqual(obj1,obj2)   ===  true

function isObject(obj) {
    return typeof obj === 'object' && obj !== null
}
function  isEqual(obj1,obj2){
  if(!isObject(obj1)||!isObject(obj2))  return obj1===obj2
if(obj1===obj2)  return true
const obj1Keys=Object.keys(obj1)
const obj2Keys=Object.keys(obj2)
if(obj1Keys.length!==obj2Keys.length) return false
for(let key in obj1){
  const res=isEqual(obj1[key],obj2[key])
  if(!res)  return res
}
return true
}

```



### 21.数组对象去重

```js
var arr = [{name: 'a',id: 1}, {name: 'a',id: 2}, {name: 'b',id: 3}, {name: 'c',id: 4},
 {name: 'c',id: 6}, {name: 'b',id: 6}, {name: 'd',id: 7}];
function deWeight() {
    for (var i = 0; i < arr.length - 1; i++) {
        for (var j = i + 1; j < arr.length; j++) {
            if (arr[i].name == arr[j].name) {
                arr.splice(j, 1);
                //因为数组长度减小1，所以直接 j++ 会漏掉一个元素，所以要 j--
                j--;
            }
        }
    }
    return arr;
}
var newArr = deWeight();
console.log('%c%s', 'color:red;', '方法一：es5,newArr', newArr);
```



```js
var arr = [{
    "name": "ZYTX",
    "age": "19",
    "gender": "f"
}, {
    "name": "ZYTA",
    "age": "18",
    "gender": "m"
}, {
    "name": "ZDTX",
    "age": "20",
    "gender": "f"
}, {
    "name": "ZYTX",
    "age": "21",
    "gender": "m"
}];
var hash = {};
arr = arr.reduce(function(item, next) {
    hash[next.name] ? '' : hash[next.name] = true && item.push(next);
    return item
}, [])
console.log(arr);
```

对于不指定的属性的对象比较 可以运用isEqual来判断是否相等 然后再对数组进行遍历判断  来进行去重

### 22.实现对象嵌套



input ["a","b","c","d","e","f","g"]

output {"a":{"b":{"c":{"d":{"e":{"f":"g"}}}}}}

```javascript
function handler(arr){
    const len = arr.length;
    let prev = {
        [arr[len-2]]:arr[len-1]
    }
    for(let i=len-3;i>=0;i--){
        prev = {
            [arr[i]]:prev
        }
    }
    return prev
}
```

### 23.获取页面dom元素

得到一个数组，数组的每一项是一个标签名

```js
const all = Array.from(document.querySelectorAll("*"));
const hash = {};
const res = [];
all.forEach(it=>{
    if(!hash[it.tagName]){
        res.push(it.tagName);
        hash[it.tagName] = true;
    }
})
console.log(res)
```

### 24.压缩字符串

字符串`aabcccccaaa`会变为`a2b1c5a3`

```js
var compressString = function (S) {
	let result = ''
	let index = 0 //记录字符出现次数，默认为1 
	let count = 1
	while (index < S.length) {
		//如果当前字符不等于下一个字符，则停止当前字符的计数，统计到result中，否则计数+1 
		if (S[index] !== S[index + 1]) {
			result += S[index] + count //当前字符计数完成后 重置计数为默认值 
			count = 1
		} else {
			count++
		}
		index++
	}
	return result.length >= S.length ? S : result
};
```

 

输入50a6we8y20x

输出50个a，6个we，8个y，20个x

```js
function getStr(str) {
      let res = [];
      for (let i = 0; i < str.length; i++) {
        if (str[i] >= 0 && str[i] <= 9) {
          res.push(str[i]);
        } else {
          let count = Number(res.join(""));
          while (count > 0) {
            console.log(str[i]);
            count--;
          }
          count = 0;
          res = [];
        }
      }
    }
    getStr("50a6we8y20x");
```



### 25.求数组交集并集差集(数组对象)

#### 数组

##### 取并集

```js
let a=new Set([1,2,3,4,5]);
let b=new Set([1,2,3,4,5,6,7,8,9]);
let arr = Array.from(new Set([...a, ...b]));
console.log('arr',arr);
```

结果： [1,2,3,4,5,6,7,8,9]

##### **取交集**

```js
let a=new Set([1,2,3,4,5]);
let b=new Set([1,2,3,4,5,6,7,8,9]);
let arr = Array.from(new Set([...b].filter(x => a.has(x))));
```

结果： [1,2,3,4,5]

##### 取差集

```js
let a=new Set([1,2,3,4,5]);
let b=new Set([1,2,3,4,5,6,7,8,9]);
let arr = Array.from(new Set([...b].filter(x => !a.has(x))));
console.log('arr',arr);
```

结果： [6,7,8,9]

#### 数组对象

##### 取交集

```js
let a=[{id:1,a:123,b:1234},{id:2,a:123,b:1234}];
let b=[{id:1,a:123,b:1234},{id:2,a:123,b:1234},{id:3,a:123,b:1234},{id:4,a:123,b:1234}];
let arr = [...b].filter(x => [...a].some(y => y.id === x.id));
console.log('arr',arr)
```

结果：

```js
[{id:1,a:123,b:1234},{id:2,a:123,b:1234}]
```

##### 取差集

```js
let a=[{id:1,a:123,b:1234},{id:2,a:123,b:1234}];
let b=[{id:1,a:123,b:1234},{id:2,a:123,b:1234},{id:3,a:123,b:1234},{id:4,a:123,b:1234}];
let arr = [...b].filter(x => [...a].every(y => y.id !== x.id));
console.log('arr',arr);
```

结果

```js
[{id:3,a:123,b:1234},{id:4,a:123,b:1234}]
```

### 26.实现(5).add(3).minus(2)

通过在原型上挂载方法实现  返回this

```js
~(function () {
        function check(n) {
          n = Number(n);
          return isNaN(n) ? 0 : n;
        }
        function add(num) {
          n = check(n);
          return this + num;
        }
        function minus(num) {
          n = check(n);
          return this - num;
        }
        Number.prototype.add = add;
        Number.prototype.minus = minus;
      })();
      console.log((5).add(3).minus(2));
```

### 27.把字符串字母大小写变换

如何把一个字符串的大小写反写(大写变小写，小写变大写),例如‘AbC’变成‘aBc’ 

```js
 let strs = "zhufengPEIxun的xxx老师很帅!,哦*100!HaHa";
      strs = strs.replace(/[a-zA-Z]/g, (content) => {
        //content:每一次正则匹配的结果
        //验证是否为大写字母:把字母转换为大写后看和之前是否一样,如果一样,之前也是大写的;在
        //ASCII表中找到大写字母的取值范围进行判断;
        //content.toUpperCase() === content;
        //content.charCodeAt()>=65&&content.charCodeAt()<=90
        return content.toUpperCase() === content
          ? content.toLowerCase()
          : content.toUpperCase();
      });
      console.log(strs);
```

### 29.实现只执行一次的函数

```js
function once(func) {
        var num = true;
        return function () {
          if (num != true) {
            return;
          } else {
            func();
            num = false;
          }
        };
      }

      function shuchu() {
        console.log(666);
      }
      getLog = once(shuchu);
      getLog();
      getLog();
```

### 30.实现对象数组分类

```js
// 将arr转换成下面这样子

   const arr = [
   { a: 1, b: 2 },
   { a: 2, b: 3 },
    { a: 1, b: 4 },
    { a: 2, b: 5 },
   ];
 // [[{ a: 1, b: 2 },{ a: 1, b: 4 }],[{ a: 2, b: 3 },{ a: 2, b: 5 }]]
```

通过map进行记录

```js
function getName(arr) {
        let result = [];
        const map = new Map();
        let index = 0;
        for (let key of arr) {
          if (!map.has(key.a)) {
            map.set(key.a, index);
            let current = [key];
            result.push(current);
            index++;
          } else {
            let suoyin = map.get(key.a);
            result[suoyin].push(key);
          }
        }
        return result;
      }
      console.log(getName(arr));
```

31.树形结构转dom

```js
let domtree=[
	{tag:'body',children:[{tag:'a',text:'some text',attribute:{a:'b'}}]
		[{tag:'div',children:['text',{tag:'a'}]}]
},
]
var father=document.querySelector('html')
function dataToDom(arr,father) {
	if(arr.children){
		for(let i=0;i<arr.children.length;i++) {
			const currentFatherDom=document.createElement(arr.tag)
			dataToDom(arr[i],currentFatherDom)
		}
	}else{
		const son=document.createElement(arr.tag)
		father.appendChild(son)
	}
}
console.log(dataToDom(domtree, father))
```






------



## 场景题

### 1.循环打印黄绿蓝

#### 普通递归

```js
const task = (timer, light, callback) => {
    setTimeout(() => {
        if (light === 'red') {
            red()
        }
        else if (light === 'green') {
            green()
        }
        else if (light === 'yellow') {
            yellow()
        }
        callback()
    }, timer)
}
const step = () => {
    task(3000, 'red', () => {
        task(2000, 'green', () => {
            task(1000, 'yellow', step)
        })
    })
}
step()
```

#### 使用promise实现

```js
const task = (timer, light) => 
    new Promise((resolve, reject) => {
        setTimeout(() => {
            if (light === 'red') {
                red()
            }
            else if (light === 'green') {
                green()
            }
            else if (light === 'yellow') {
                yellow()
            }
            resolve()
        }, timer)
    })
const step = () => {
    task(3000, 'red')
        .then(() => task(2000, 'green'))
        .then(() => task(2100, 'yellow'))
        .then(step)
}
step()
```

#### 用 async/await 实现

```js
const task = (timer, light) => 
    new Promise((resolve, reject) => {
        setTimeout(() => {
            if (light === 'red') {
                red()
            }
            else if (light === 'green') {
                green()
            }
            else if (light === 'yellow') {
                yellow()
            }
            resolve()
        }, timer)
    })
    
const taskRunner =  async () => {
    await task(3000, 'red')
    await task(2000, 'green')
    await task(2100, 'yellow')
    taskRunner()
}
taskRunner()

```



### 2.图片懒加载

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Document</title>
  </head>
  <style>
    .container {
      width: 1000px;
      margin: 0 auto;
      background-color: pink;
    }
    .container > img {
      display: block;
      width: 400px;
      height: 400px;
      margin-bottom: 50px;
    }
  </style>
  <body>
    <div class="container">
      <img src="./img/loading.jpg" data-src="./img/pic.png" />
      <img src="./img/loading.jpg" data-src="./img/pic.png" />
      <img src="./img/loading.jpg" data-src="./img/pic.png" />
      <img src="./img/loading.jpg" data-src="./img/pic.png" />
      <img src="./img/loading.jpg" data-src="./img/pic.png" />
      <img src="./img/loading.jpg" data-src="./img/pic.png" />
    </div>
    <script>
      function lazyLoad() {
        var scrollTop =
          document.body.scrollTop || document.documentElement.scrollTop;
        var winHeight = window.innerHeight;
        for (var i = 0; i < imgs.length; i++) {
          if (imgs[i].offsetTop < scrollTop + winHeight) {
            imgs[i].src = imgs[i].getAttribute("data-src");
          }
        }
      }
      window.onscroll = lazyLoad();
    </script>
  </body>
</html>
```



### 3.promise实现图片异步加载

```js
let imageAsync=(url)=>{
    return new Promise((resolve,reject)=>{
        let img=new Image();
        img.src=url;
        img.onload=()=>{
            resolve(image)
        }
        img.onerror=(err)=>{
            reject(err)
        }
    })
}
imageAsync("url").then(()=>{
    console.log('加载成功')
}).catch((error)=>{
    console.log('加载失败')
})
```



### 4.每隔1秒打印

```js
// 使用闭包实现
for (var i = 0; i < 5; i++) {
  (function(i) {
    setTimeout(function() {
      console.log(i);
    }, i * 1000);
  })(i);
}
// 使用 let 块级作用域
for (let i = 0; i < 5; i++) {
  setTimeout(function() {
    console.log(i);
  }, i * 1000);
}
```

```js
function sleep(time){
    for(let i=0;i<5;i++){
        Promise.resolve(i).then((result)=>{
            setTimeout(()=>{
                console.log(result)
            },time*result)
        })
    }
}
sleep(1000)
```



### 5.双向数据绑定

```js
 //=>发布订阅的类
      class EventEmitter {
        constructor() {
          this.arrayList = {};
        }
        on(name, fn) {
          if (this.arrayList[name] && !this.arrayList[name].includes(fn)) {
            this.arrayList[name].push(fn);
          } else {
            this.arrayList[name] = [fn];
          }
          console.log(this.arrayList);
        }
        off(name, fn) {
          if (this.arrayList[name]) {
            let index = this.arrayList[name].indexOf(fn);
            this.arrayList[name].splice(index, 1);
            console.log(this.arrayList);
          }
        }
        emit(name, once = false, ...arg) {
          if (this.arrayList[name]?.length > 0) {
            for (let key of this.arrayList[name]) {
              key.call(this, arg);
            }
          }
          if (!once) {
            delete this.arrayList[name];
          }
          console.log(this.arrayList);
        }
      }
      let s1 = new EventEmitter();
      let f1 = function () {
        console.log(666);
      };
      let f2 = function () {
        console.log(777);
      };
      var input = document.querySelector("#ipt");
      input.oninput = function (e) {
        obj.value = e.target.value;
      };
      let obj = {
        value: "",
      };
      Object.defineProperty(obj, "value", {
        get() {
          console.log("我被读了");
        },
        set(newVal) {
          s1.on("value1", function () {
            console.log("我的值是" + newVal);
            console.log("我被改了");
          });
          input.value = newVal;
          return newVal;
        },
      });
```



### 6.观察者模式

在观察者模式中，只有两个主体，分别是目标对象`Subject`，观察者`Observer`。

- 观察者需`Observer`要实现`update`方法，供目标对象调用。`update`方法中可以执行自定义的业务代码。
- 目标对象`Subject`也通常被叫做被观察者或主题，它的职能很单一，可以理解为，它只管理一种事件。`Subject`需要维护自身的观察者数组`observerList`，当自身发生变化时，通过调用自身的`notify`方法，依次通知每一个观察者执行`update`方法。

![观察者模式](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/12/16ef7fe567bdf007~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)

```js
// 观察者
class Observer {
    /**
     * 构造器
     * @param {Function} cb 回调函数，收到目标对象通知时执行
     */
    constructor(cb){
        if (typeof cb === 'function') {
            this.cb = cb
        } else {
            throw new Error('Observer构造器必须传入函数类型！')
        }
    }
    /**
     * 被目标对象通知时执行
     */
    update() {
        this.cb()
    }
} 

// 目标对象
class Subject {
    constructor() {
        // 维护观察者列表
        this.observerList = []
    }
    /**
     * 添加一个观察者
     * @param {Observer} observer Observer实例
     */
    addObserver(observer) {
        this.observerList.push(observer)
    }
    /**
     * 通知所有的观察者
     */
    notify() {
        this.observerList.forEach(observer => {
            observer.update()
        })
    }
}

const observerCallback = function() {
    console.log('我被通知了')
}
const observer = new Observer(observerCallback)

const subject = new Subject();
subject.addObserver(observer);
subject.notify();

```

- 角色很明确，没有事件调度中心作为中间者，目标对象`Subject`和观察者`Observer`都要实现约定的成员方法。
- 双方联系更紧密，目标对象的主动性很强，自己收集和维护观察者，并在状态变化时主动通知观察者更新。

### 7.发布订阅模式

![发布订阅模式图解](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/12/16ef7fe5614d6ea0~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)

```js
class PubSub {
    constructor() {
        // 维护事件及订阅行为
        this.events = {}
    }
    /**
     * 注册事件订阅行为
     * @param {String} type 事件类型
     * @param {Function} cb 回调函数
     */
    subscribe(type, cb) {
        if (!this.events[type]) {
            this.events[type] = []
        }
        this.events[type].push(cb)
    }
    /**
     * 发布事件
     * @param {String} type 事件类型
     * @param  {...any} args 参数列表
     */
    publish(type, ...args) {
        if (this.events[type]) {
            this.events[type].forEach(cb => {
                cb(...args)
            })
        }
    }
    /**
     * 移除某个事件的一个订阅行为
     * @param {String} type 事件类型
     * @param {Function} cb 回调函数
     */
    unsubscribe(type, cb) {
        if (this.events[type]) {
            const targetIndex = this.events[type].findIndex(item => item === cb)
            if (targetIndex !== -1) {
                this.events[type].splice(targetIndex, 1)
            }
            if (this.events[type].length === 0) {
                delete this.events[type]
            }
        }
    }
    /**
     * 移除某个事件的所有订阅行为
     * @param {String} type 事件类型
     */
    unsubscribeAll(type) {
        if (this.events[type]) {
            delete this.events[type]
        }
    }
}

```

发布订阅模式中，对于发布者`Publisher`和订阅者`Subscriber`没有特殊的约束，他们好似是匿名活动，借助事件调度中心提供的接口发布和订阅事件，互不了解对方是谁。

松散耦合，灵活度高，常用作事件总线

易理解，可类比于`DOM`事件中的`dispatchEvent`和`addEventListener`。

### 8.单例模式

[相关文章](https://juejin.cn/post/6844903874210299912)

### 9.工厂模式

[相关文章](https://juejin.cn/post/6844903474639929357)

### 10.Eventbus

```js
//仓库
class EventBus{
    constructor(){
        this.events={}
    }
    //添加
    on(name,fn){
        //有这个属性则添加，没有则赋值
        if(this.events[name]){
            this.events[name].push(fn)
        }else{
            this.events[name]=[fn]
        }
    }
    //移除(事件名下的某个fn)
    off(name,fn){
        //获得事件数组
        let tasks=this.events[name]
        if(tasks){
            //找到fn(函数名或者匿名函数),找不到返回-1
            const index=tasks.findIndex(f=>f===fn||f.callback===fn)
            if(index>=0){
                //删除
                tasks.splice(index,1)
            }
        }
    }
    //触发,once只触发一次
    emit(name,once=false,...args){
        if(this.events[name]){
            //触发的事件里如果又添加了相同的事件名，会陷入死循环
            let tasks=this.events[name].slice()
            for(let fn of tasks){
                //执行
                fn(...args)
            }
            if(once){
                delete this.events[name]
            }
        }
    }
}
let eventBus = new EventBus()
let fn1 = function(name, age) {
	console.log(`${name} ${age}`)
}
let fn2 = function(name, age) {
	console.log(`hello, ${name} ${age}`)
}
eventBus.on('aaa', fn1)
eventBus.on('aaa', fn2)

eventBus.off("aaa",fn1)
eventBus.emit('aaa', false, '布兰', 12)
```

### 11.实现checkbox全选反选

js实现

```js
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8" />
		<title></title>
		<style type="text/css">
			* {
				padding: 0px;
				margin: 0px auto;
			}			
			body {
				padding: 30px;
				width: 300px;
				height: 300px;
			}
		</style>
		<script type="text/javascript">
			window.onload = function() {
				//获取五个多选框items
				var items = document.getElementsByName("items");

				//1.checkAllBtn绑定单击响应函数
				var checkAllBtn = document.getElementById("checkAllBtn");
				checkAllBtn.onclick = function() {
					//遍历items,使每个复选框都被选中
					for(var i = 0; i < items.length; i++) {
						items[i].checked = true;
					}
				};

				//2.checkNoBtn绑定单击响应函数
				var checkNoBtn = document.getElementById("checkNoBtn");
				checkNoBtn.onclick = function() {
					//遍历items,使每个复选框都不被选中
					for(var i = 0; i < items.length; i++) {
						items[i].checked = false;
					}
				};

				//3.checkRevBtn绑定单击响应函数
				var checkRevBtn = document.getElementById("checkRevBtn");
				checkRevBtn.onclick = function() {
					//遍历items,进行反选
					for(var i = 0; i < items.length; i++) {
//						if(items[i].checked) {
//							items[i].checked = false;
//						} else if(items[i].checked == false) {
//							items[i].checked = true;
//						}
						items[i].checked = !items[i].checked;
					}

				};

			};
		</script>
	</head>

	<body>
		<input type="button" id="checkAllBtn" value="全选" />
		<input type="button" id="checkNoBtn" value="不选" />
		<input type="button" id="checkRevBtn" value="反选" />
		<div id="select">
			<input type="checkbox" name="items" value="旅游" />旅游<br />
			<input type="checkbox" name="items" value="阅读" />阅读<br />
			<input type="checkbox" name="items" value="运动" />运动<br />
			<input type="checkbox" name="items" value="音乐" />音乐<br />
			<input type="checkbox" name="items" value="跳舞" />跳舞
		</div>
	</body>
</html>
```

vue实现

```vue
<template>
  <div>
    <span>全选</span>
    <input type="checkbox" v-model="checkAll" />
    <div v-for="(item,index) in test" :key="index">
      <span>{{item.name}}</span>
	  <input type="checkbox" v-model="item.isSelected" />
    </div>
  </div>
</template>
<script>
  export default {
  data() {
    return {
      test: [
        { name: "测试1", isSelected: true },
        { name: "测试2", isSelected: true },
        { name: "测试3", isSelected: true },
        { name: "测试4", isSelected: true },
        { name: "测试5", isSelected: true }
      ]
    };
  },
  computed: {
    checkAll: {
      get() {
        // 返回什么结果接赋予给 checkAll 属性
        return this.test.every(item => item.isSelected);
      },
      set(val) {
        // val 是给 checkAll 赋予值的时候传递过来的
        return this.test.forEach(item => (item.isSelected = val));
      }
    }
  }
}
</script>
```

### 12.实现可拖拽div

```html
<div id="box"></div>
<style>
    #box {
        position: absolute;	// 重要
        border: 1px solid red;
        height: 100px;
        width: 100px;
    }
</style>
<script>
    let dragging = false
    let position = null
    box.addEventListener('mousedown', function (e) {
        dragging = true // 正在移动
        position = [e.clientX, e.clientY]
    })
    document.addEventListener('mousemove', function (e) {
        if (dragging === false) {
            return
        }
        const x = e.clientX
        const y = e.clientY
        const deltaX = x - position[0]
        const deltaY = y - position[1]
        const left = parseInt(box.style.left || 0)
        const top = parseInt(box.style.top || 0)
        box.style.left = left + deltaX + 'px'
        box.style.top = top + deltaY + 'px'
        position = [x, y]
    })
    document.addEventListener('mouseup', function (e) {
        dragging = false
    })
</script>

//实现拖拽圆形
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title></title>
    <style>
      .rad{
        height: 100px;
        width: 100px;
        background-color: red;
        border-radius: 50%;
        position: absolute;
      }
    </style>
  </head>
  <body>
    <div class="rad"></div>
    <script>
    let screenLog=document.querySelector('.rad');
    document.addEventListener('mousemove',(e)=>{
      screenLog.style.left=e.x-screenLog.offsetWidth/2+'px';
      screenLog.style.top=e.y-screenLog.offsetHeight/2+'px';
    })

    </script>
  </body>
</html>
```

拖拽案例

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        .parent {
            height: 200px;
            border: 1px solid cyan;
            margin: 0 auto;
        }
        .child {
            width: 100px;
            height: 100px;
            border: 1px solid red;
            float: left;
            margin: 10px;
        }
        body {
            height: 400px;
        }
    </style>
    <script>
        window.onload = function () {
            var parent = document.querySelector('.parent');
            var childs = document.querySelectorAll('.child');
            childs = Array.from(childs);
            // console.log(childs);
            childs.forEach(function (item) {
                //拖放对象
                //拖放事件
                //开始拖放
                item.ondragstart = function (event) {
                    // console.log('ondragstart');
                    //console.log(event.dataTransfer);
                    event.dataTransfer.setData('id', item.id);
                };
                //正在拖放的事件
                item.ondrag = function () {
                    // console.log('ondrag');
                }
                //拖放结束
                item.ondragend = function () {
                    // console.log('ondragend');
                }
            })
            //放置对象事件
            //将拖放元素 拖放放置 对象中
            // 进入目标元素
            parent.ondragenter = function (event) {

            }
            // 在目标元素内活动
            parent.ondragover = function () {
                //取消事件默认行为
                event.preventDefault();
            }
            // 将拖放元素放置到目标元素内
            parent.ondrop = function (event) {
                // console.log('ondrop');
                var id = event.dataTransfer.getData('id');
                //    id='one'
                var dom = document.querySelector('#' + id);
                this.appendChild(dom);
                event.stopPropagation();

            }
            document.body.ondragover = function (event) {
                event.preventDefault();
            }
            document.body.ondrop = function (event) {
                var id = event.dataTransfer.getData('id');
                var dom = document.querySelector('#' + id);
                this.appendChild(dom);
            }
        }
    </script>
</head>

<body>
    <div class="parent">
    </div>
    <div class="child" draggable="true" id="one">1</div>
    <div class="child" draggable="true" id="two">2</div>
    <div class="child" draggable="true" id='three'>3</div>
    <div class="child" draggable="true" id='four'>4</div>
</body>

</html>

```



### 13.封装异步的fetch，使用async await方式来使用

```js
(async () => {
    class HttpRequestUtil {
        async get(url) {
            const res = await fetch(url);
            const data = await res.json();
            return data;
        }
        async post(url, data) {
            const res = await fetch(url, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(data)
            });
            const result = await res.json();
            return result;
        }
        async put(url, data) {
            const res = await fetch(url, {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json'
                },
                data: JSON.stringify(data)
            });
            const result = await res.json();
            return result;
        }
        async delete(url, data) {
            const res = await fetch(url, {
                method: 'DELETE',
                headers: {
                    'Content-Type': 'application/json'
                },
                data: JSON.stringify(data)
            });
            const result = await res.json();
            return result;
        }
    }
    const httpRequestUtil = new HttpRequestUtil();
    const res = await httpRequestUtil.get('http://golderbrother.cn/');
    console.log(res);
})();
```

### 14.实现简单路由

```js
// hash路由
class Route{
  constructor(){
    // 路由存储对象
    this.routes = {}
    // 当前hash
    this.currentHash = ''
    // 绑定this，避免监听时this指向改变
    this.freshRoute = this.freshRoute.bind(this)
    // 监听
    window.addEventListener('load', this.freshRoute, false)
    window.addEventListener('hashchange', this.freshRoute, false)
  }
  // 存储
  storeRoute (path, cb) {
    this.routes[path] = cb || function () {}
  }
  // 更新
  freshRoute () {
    this.currentHash = location.hash.slice(1) || '/'
    this.routes[this.currentHash]()
  }
}

```

### 15.判断对象是否存在循环引用

```js
const isCycleObject = (obj,parent) => {
    const parentArr = parent || [obj];
    for(let i in obj) {
        if(typeof obj[i] === 'object') {
            let flag = false;
            parentArr.forEach((pObj) => {
                if(pObj === obj[i]){
                    flag = true;
                }
            })
            if(flag) return true;
            flag = isCycleObject(obj[i],[...parentArr,obj[i]]);
            if(flag) return true;
        }
    }
    return false;
}


const a = 1;
const b = {a};
const c = {b};
const o = {d:{a:3},c}
o.c.b.aa = a;

console.log(isCycleObject(o)
```

### 16.实现并发控制

同时进行2个并发请求

```js
class Scheduler{
	list=[];
	maxNum=2;
	workingNum=0;
	add(promiseCreator){
		this.list.push(promiseCreator)
	}
	start(){
			for(let i=0;i<this.maxNum;i++){
				this.doNext()
			}
	}
	doNext(){
		if(this.list.length&&this.workingNum<this.maxNum){
			this.workingNum++
			this.list.shift()().then(()=>{
				this.workingNum--
				this.doNext()
			})
		}
	}
}
var timeout=time=>new Promise(resolve=>setTimeout(resolve,time))

var scheduler=new Scheduler()

var addTask=(time,order)=>{
	scheduler.add(()=>timeout(time).then(()=>console.log(order)))
}
addTask(1000,1)
addTask(500,2)
addTask(300,3)
addTask(400,4)

scheduler.start()
```



我们在需要保证代码在多个异步处理之后执⾏,我们通常会使⽤
Promise.all(promises: []).then(fun: function);
Promise.all可以保证，promises数组中所有promise对象都达到resolve状态，才执⾏then回调
那么会出现的情况是，你在瞬间发出⼏⼗万http请求（tcp连接数不⾜可能造成等待），或者堆积了⽆数调⽤栈导致内存溢出.
这个时候需要我们对HTTP的连接数做限制

思路如下：定义⼀个 PromisePool 对象，初始化⼀个 pool 作为并发池，

然后先循环把并发池塞满，不断地调⽤ setTask 然后通过⾃⼰⾃定义的任务函数

(任务函数可以是⽹络请求封装的 promise 对象，或者是其他的)，

⽽且每个任务是⼀个Promise对象包装的，执⾏完就 pop 出连接池，任务push 进并发池 pool 中

```js
class PromisePool{
	constructor(max,fn){
		this.max = max;
		this.fn = fn;
		this.pool=[]
		this.urls=[]
	}
	start(urls){
		this.urls=urls;
		while(this.pool.length<this.max){
			let url=this.urls.shift()
			this.setTask(url)
		}
		let race=Promise.race(this.pool)
		return this.run(race)
	}
	run(race){
		race.then(res=>{
			//跑完一个就塞进去一个
			let url=this.urls.shift()
			this.setTask(url)
			return this.run(Promise.race(this.pool))
		})
	}
	setTask(url){
		if(!url) return 
		let task=this.fn(url)
		this.pool.push(task)
		console.log(`${url}开始,当前并发数${this.pool.length})`)
		task.then(res=>{
			this.pool.splice(this.pool.indexOf(task), 1)
			console.log(`${url}结束 当前并发数${this.pool.length}`)
		})
	}
	
}
const URLS=[
	'bytedance.com',
	'tencent.com',
	'alibaba.com',
	'microsoft.com',
	'apple.com',
	'hulu.com',
	'amazon.com',
]
var requestFn=url=>{
	return new Promise(resolve=>{
		setTimeout(()=>{
			resolve(`任务${url}完成`)
		},1000)
	}).then(res=>{
		console.log('外部逻辑',res);
	})
}
const pool=new PromisePool(5,requestFn)
pool.start(URLS)
```



## 基本算法

### 快速排序

```js
function quick_sort(arr,l,r) {
		if(l>=r) return
		let x=arr[l],i=l-1,j=r+1;
		while(i<j){
			do{
				j--;
			}while(arr[j]>x);
			do{
				i++;
			}while(arr[i]<x);
			if(i<j){
				let temp=arr[i];
				arr[i]=arr[j];
				arr[j]=temp;
			}
		}
		quick_sort(arr,l,j);
		quick_sort(arr,j+1,r );
}
let arr=[10,9,8,7,6,5,4,3,2,1];
quick_sort(arr,0,arr.length-1);
console.log(arr);
```

### 归并排序

```js

let arr=[20,18,12,8,5,3,2,1]; 
let tmp=[];
merge_sort(arr,0,arr.length-1);
console.log(arr);


function merge_sort(arr, l, r) {
	if (l >= r) return;
	if (l < r) {
		var mid = Math.floor((l + r) / 2);
		merge_sort(arr, l, mid);
		merge_sort(arr, mid + 1, r);
	}
	let k = 0, i = l, j = mid + 1;
	while (i <= mid && j <= r) {
		if (arr[i] < arr[j]) {
			tmp[k++] = arr[i++];
		} else {
			tmp[k++] = arr[j++];
		}
	}
	while (i <= mid) {
		tmp[k++] = arr[i++];
	}
	while(j <= r) {
		tmp[k++] = arr[j++];
	}
	for(let i = 0; i < k; i++) {
		arr[l+i] = tmp[i];
		console.log(arr[l + i],l+i);
	}
}
```

### 冒泡排序

```js
function bubbleSort(list) {
  var n = list.length;
  if (!n) return [];

  for (var i = 0; i < n; i++) {
    // 注意这里需要 n - i - 1
    for (var j = 0; j < n - i - 1; j++) {
      if (list[j] > list[j + 1]) {
        var temp = list[j + 1];
        list[j + 1] = list[j];
        list[j] = temp;
      }
    }
  }
  return list;
}
```



### 整数二分

```js
function bsearch(){
		var arr = [1,2,3,4,5,6,6,7,8,9,10,10];
		var l=0,r=arr.length-1;
		
		var target = 6;
		while(l<=r){
			var mid = Math.floor((l+r)/2);
			if(arr[mid]==target){
				return mid;
			}else if(arr[mid]>target){
				r = mid-1;
			}else{
				l = mid+1;
			}
			
		}
		return -1;
}
console.log(bsearch());
```

